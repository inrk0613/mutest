<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Silent Clipper | AI-Powered Video Silence Remover</title>

    <!-- FFmpeg.wasm Scripts (Updated Versions) -->
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js"></script>
    <script src="https://unpkg.com/@ffmpeg/util@0.12.1/dist/util.min.js"></script>

    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-color: #0A84FF;
            --text-color: #e0e0e0;
            --text-secondary-color: #888;
            --border-color: #333;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --border-radius: 12px;
            --transition-speed: 0.3s;
        }

        /* Reset and Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Main Application Layout */
        .app-container {
            width: 100%;
            max-width: 1200px;
            height: 95vh;
            max-height: 900px;
            background-color: var(--surface-color);
            border-radius: var(--border-radius);
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        header h1 {
            font-size: 1.25rem;
            font-weight: 600;
        }

        /* Main Content Area */
        main {
            display: flex;
            flex-grow: 1;
            height: 100%;
            min-height: 0; /* Important for flexbox shrinking */
        }
        
        .video-panel {
            flex-grow: 1;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
        }
        .controls-panel {
            width: 320px;
            flex-shrink: 0;
            border-left: 1px solid var(--border-color);
            padding: 1.5rem;
            overflow-y: auto;
        }

        /* File Drop Zone */
        .file-drop-zone {
            flex-grow: 1;
            border: 2px dashed var(--border-color);
            border-radius: var(--border-radius);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            cursor: pointer;
            transition: background-color var(--transition-speed), border-color var(--transition-speed);
        }
        .file-drop-zone.dragover {
            background-color: rgba(10, 132, 255, 0.1);
            border-color: var(--primary-color);
        }
        .file-drop-zone h2 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }
        .file-drop-zone p {
            color: var(--text-secondary-color);
        }
        #fileInput { display: none; }
        
        /* Video Player Area */
        .video-wrapper {
            position: relative;
            width: 100%;
            flex-grow: 1;
            background-color: #000;
            border-radius: var(--border-radius);
            overflow: hidden;
            display: none; /* Initially hidden */
        }
        #videoPlayer {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Histogram */
        #histogramCanvas {
            width: 100%;
            height: 80px;
            margin-top: 1rem;
            border-radius: 4px;
            background-color: #2a2a2a;
            cursor: crosshair;
        }
        
        /* Loading Spinner */
        .loader-overlay {
            position: absolute;
            inset: 0;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--border-color);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        #progressText {
            margin-top: 1rem;
            color: var(--text-color);
            font-size: 0.9rem;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Controls Panel */
        .controls-panel h3 {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.75rem;
        }
        .control-group {
            margin-bottom: 1.5rem;
        }
        .control-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
            font-weight: 500;
        }
        .control-group .value {
            color: var(--text-secondary-color);
            font-weight: 400;
        }
        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: var(--border-color);
            outline: none;
            border-radius: 2px;
            transition: opacity var(--transition-speed);
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            cursor: pointer;
            border-radius: 50%;
        }
        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        /* Export Button */
        #exportButton {
            width: 100%;
            padding: 12px;
            font-size: 1rem;
            font-weight: 600;
            color: #fff;
            background-color: var(--primary-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color var(--transition-speed);
        }
        #exportButton:hover {
            background-color: #0077ED;
        }
        #exportButton:disabled {
            background-color: var(--border-color);
            cursor: not-allowed;
        }
        
        /* Utility */
        .hidden { display: none !important; }

        /* Responsive */
        @media (max-width: 900px) {
            body { align-items: flex-start; }
            .app-container { 
                flex-direction: column; 
                height: 100vh;
                max-height: none;
                border-radius: 0;
            }
            main { flex-direction: column; }
            .controls-panel {
                width: 100%;
                border-left: none;
                border-top: 1px solid var(--border-color);
                max-height: 40vh;
            }
        }
    </style>
</head>
<body>

    <div class="app-container">
        <header>
            <h1>Silent Clipper</h1>
        </header>
        <main>
            <div class="video-panel">
                <div class="file-drop-zone" id="fileDropZone">
                    <input type="file" id="fileInput" accept="video/mp4,video/webm,video/quicktime,video/*">
                    <h2>ビデオファイルをドラッグ＆ドロップ</h2>
                    <p>またはクリックしてファイルを選択</p>
                </div>

                <div class="video-wrapper" id="videoWrapper">
                    <video id="videoPlayer" controls></video>
                    <div class="loader-overlay hidden" id="loaderOverlay">
                        <div class="spinner"></div>
                        <p id="progressText">準備中...</p>
                    </div>
                </div>

                <canvas id="histogramCanvas"></canvas>
            </div>
            <aside class="controls-panel" id="controlsPanel">
                <div class="export-section" style="margin-bottom: 1.5rem;">
                    <button id="exportButton">書き出し</button>
                    <div id="exportProgress" class="hidden" style="margin-top: 0.75rem;">
                        <p id="exportProgressText" style="font-size: 0.9rem; margin-bottom: 0.5rem;"></p>
                        <progress id="exportProgressBar" value="0" max="100" style="width: 100%;"></progress>
                    </div>
                </div>
                <h3>設定</h3>
                <div class="control-group">
                    <label for="thresholdSlider">無音しきい値 <span class="value" id="thresholdValue">-40 dB</span></label>
                    <input type="range" min="-60" max="-20" value="-40" class="slider" id="thresholdSlider">
                </div>
                <div class="control-group">
                    <label for="chunkSizeSlider">解析間隔 <span class="value" id="chunkSizeValue">50 ms</span></label>
                    <input type="range" min="10" max="200" value="50" step="10" class="slider" id="chunkSizeSlider">
                </div>
                <div class="control-group">
                    <label for="minSilenceSlider">最小無音長 <span class="value" id="minSilenceValue">500 ms</span></label>
                    <input type="range" min="100" max="2000" value="500" step="50" class="slider" id="minSilenceSlider">
                </div>
                <div class="control-group">
                    <label for="paddingSlider">マージン <span class="value" id="paddingValue">100 ms</span></label>
                    <input type="range" min="0" max="500" value="100" step="10" class="slider" id="paddingSlider">
                </div>
            </aside>
        </main>
    </div>

    <script type="module">
    // ===================================================================================
    // --- TYPE DEFINITIONS (JSDoc for TypeScript-like type safety) ---
    // ===================================================================================

    /**
     * @typedef {object} TimeRange
     * @property {number} start - Start time in seconds.
     * @property {number} end - End time in seconds.
     */
    
    // ===================================================================================
    // --- APPLICATION STATE ---
    // ===================================================================================
    
    const state = {
        videoFile: null,
        videoObjectURL: null,
        audioData: null,
        sampleRate: 0,
        soundZones: [],
        isProcessing: false,
        currentSoundZoneIndex: 0,
    };

    // ===================================================================================
    // --- DOM ELEMENTS ---
    // ===================================================================================
    
    const dom = {
        fileDropZone: document.getElementById('fileDropZone'),
        fileInput: document.getElementById('fileInput'),
        videoWrapper: document.getElementById('videoWrapper'),
        videoPlayer: document.getElementById('videoPlayer'),
        loaderOverlay: document.getElementById('loaderOverlay'),
        progressText: document.getElementById('progressText'),
        histogramCanvas: document.getElementById('histogramCanvas'),
        controlsPanel: document.getElementById('controlsPanel'),
        thresholdSlider: document.getElementById('thresholdSlider'),
        chunkSizeSlider: document.getElementById('chunkSizeSlider'),
        minSilenceSlider: document.getElementById('minSilenceSlider'),
        paddingSlider: document.getElementById('paddingSlider'),
        thresholdValue: document.getElementById('thresholdValue'),
        chunkSizeValue: document.getElementById('chunkSizeValue'),
        minSilenceValue: document.getElementById('minSilenceValue'),
        paddingValue: document.getElementById('paddingValue'),
        exportButton: document.getElementById('exportButton'),
        exportProgress: document.getElementById('exportProgress'),
        exportProgressText: document.getElementById('exportProgressText'),
        exportProgressBar: document.getElementById('exportProgressBar'),
    };
    
    const histogramCtx = dom.histogramCanvas.getContext('2d');
    
    // ===================================================================================
    // --- WEB WORKER INITIALIZATION ---
    // ===================================================================================

    const workerCode = `
        let wasm;
        async function loadWasm() {
            wasm = {
                calculate_rms_dbfs_for_chunks: (audioData, sampleRate, chunkSizeMs) => {
                    const chunkSamples = Math.floor(sampleRate * (chunkSizeMs / 1000));
                    const numChunks = Math.floor(audioData.length / chunkSamples);
                    const volumes = new Float32Array(numChunks);
                    for (let i = 0; i < numChunks; i++) {
                        let sumOfSquares = 0;
                        const start = i * chunkSamples;
                        const end = start + chunkSamples;
                        for (let j = start; j < end; j++) {
                            sumOfSquares += audioData[j] * audioData[j];
                        }
                        const rms = Math.sqrt(sumOfSquares / chunkSamples);
                        volumes[i] = (rms > 0) ? 20 * Math.log10(rms) : -144; // Avoid -Infinity
                    }
                    return volumes;
                }
            };
        }
        
        self.onmessage = async (e) => {
            const { type, payload } = e.data;
            if (type === 'ANALYZE') {
                if (!wasm) await loadWasm();
                
                self.postMessage({ type: 'PROGRESS', payload: { text: '音量を解析中...' } });
                
                const volumes = wasm.calculate_rms_dbfs_for_chunks(
                    payload.audioData,
                    payload.sampleRate,
                    payload.params.chunkSize
                );

                self.postMessage({ type: 'HISTOGRAM_DATA', payload: { volumes, audioDataBuffer: payload.audioData.buffer } }, [payload.audioData.buffer]);

                self.postMessage({ type: 'PROGRESS', payload: { text: '無音区間を検出中...' } });

                const isSilent = new Uint8Array(volumes.length);
                for (let i = 0; i < volumes.length; i++) {
                    if (volumes[i] < payload.params.threshold) {
                        isSilent[i] = 1;
                    }
                }
                
                const minSilenceChunks = Math.ceil(payload.params.minSilenceDuration / payload.params.chunkSize);
                const paddingSeconds = payload.params.padding / 1000;
                const chunkSizeSeconds = payload.params.chunkSize / 1000;

                const soundZones = [];
                let startOfSound = 0;
                
                for(let i = 0; i < isSilent.length; i++){
                    if(isSilent[i] === 1){
                        let silenceEnd = i;
                        while(silenceEnd < isSilent.length && isSilent[silenceEnd] === 1){
                            silenceEnd++;
                        }
                        const silenceDuration = (silenceEnd - i) * chunkSizeSeconds * 1000;
                        if(silenceDuration >= payload.params.minSilenceDuration){
                            const endOfSound = i * chunkSizeSeconds;
                            if(endOfSound > startOfSound){
                                soundZones.push({
                                    start: startOfSound - paddingSeconds,
                                    end: endOfSound + paddingSeconds
                                });
                            }
                            startOfSound = silenceEnd * chunkSizeSeconds;
                        }
                        i = silenceEnd - 1;
                    }
                }

                if (startOfSound < volumes.length * chunkSizeSeconds) {
                    soundZones.push({
                        start: startOfSound - paddingSeconds,
                        end: volumes.length * chunkSizeSeconds
                    });
                }
                
                const mergedZones = soundZones.reduce((acc, current) => {
                    if (acc.length === 0) {
                        acc.push(current);
                        return acc;
                    }
                    const last = acc[acc.length - 1];
                    if (current.start <= last.end) {
                        last.end = Math.max(last.end, current.end);
                    } else {
                        acc.push(current);
                    }
                    return acc;
                }, []).map(zone => ({
                    start: Math.max(0, zone.start),
                    end: zone.end
                }));
                
                self.postMessage({ type: 'ANALYSIS_COMPLETE', payload: { soundZones: mergedZones } });
            }
        };
    `;
    const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
    const worker = new Worker(URL.createObjectURL(workerBlob));

    // ===================================================================================
    // --- FFmpeg Logic ---
    // ===================================================================================
    
    let ffmpeg;

    async function loadFFmpeg() {
        if (ffmpeg && ffmpeg.loaded) return;
        
        const { FFmpeg } = window.FFmpeg;
        const { toBlobURL } = window.FFmpegUtil;

        ffmpeg = new FFmpeg();
        ffmpeg.on('log', ({ message }) => console.log(message));
        ffmpeg.on('progress', ({ progress }) => {
            if (progress > 0 && progress <= 1) {
                const percent = Math.round(progress * 100);
                dom.exportProgressBar.value = percent;
                if (state.isProcessing) { // Only update text if it's a user-facing process
                    dom.exportProgressText.textContent = `処理中... ${percent}%`;
                }
            }
        });

        setProcessingState(true, 'コアエンジンをロード中...');
        const baseURL = "https://unpkg.com/@ffmpeg/core@0.12.6/dist/esm";
        await ffmpeg.load({
            coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, "text/javascript"),
            wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, "application/wasm"),
        });
        setProcessingState(false);
    }

    // ===================================================================================
    // --- MAIN APPLICATION LOGIC ---
    // ===================================================================================

    async function handleFileSelect(file) {
        if (!file) return;
        
        state.videoFile = file;
        setProcessingState(true, 'ファイルを準備中...');

        if (state.videoObjectURL) URL.revokeObjectURL(state.videoObjectURL);
        state.videoObjectURL = URL.createObjectURL(file);
        dom.videoPlayer.src = state.videoObjectURL;

        dom.fileDropZone.classList.add('hidden');
        dom.videoWrapper.style.display = 'block';
        
        try {
            const audioBuffer = await extractAudioWithFFmpeg(file);
            state.audioData = audioBuffer.getChannelData(0);
            state.sampleRate = audioBuffer.sampleRate;
            triggerAnalysis();
        } catch (err) {
            console.error('Error processing audio:', err);
            alert('音声トラックの処理に失敗しました。ファイルが破損しているか、サポートされていない形式の可能性があります。');
            setProcessingState(false);
        }
    }

    async function extractAudioWithFFmpeg(videoFile) {
        await loadFFmpeg();
        const { fetchFile } = window.FFmpegUtil;

        setProcessingState(true, '音声トラックを抽出中...');
        dom.exportProgress.classList.remove('hidden');
        dom.exportProgressBar.value = 0;

        await ffmpeg.writeFile(videoFile.name, await fetchFile(videoFile));

        const outputFilename = `audio_${Date.now()}.wav`;
        await ffmpeg.exec(['-i', videoFile.name, '-vn', '-acodec', 'pcm_f32le', '-ar', '48000', '-ac', '1', outputFilename]);

        setProcessingState(true, '音声データをデコード中...');
        const audioData = await ffmpeg.readFile(outputFilename);
        
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await audioContext.decodeAudioData(audioData.buffer);
        
        await ffmpeg.deleteFile(videoFile.name);
        await ffmpeg.deleteFile(outputFilename);
        
        dom.exportProgress.classList.add('hidden');
        return audioBuffer;
    }
        
    function triggerAnalysis() {
        if (!state.audioData) return;
        setProcessingState(true, '解析の準備中...');
        
        const params = {
            threshold: parseFloat(dom.thresholdSlider.value),
            chunkSize: parseInt(dom.chunkSizeSlider.value, 10),
            minSilenceDuration: parseInt(dom.minSilenceSlider.value, 10),
            padding: parseInt(dom.paddingSlider.value, 10),
        };

        worker.postMessage({
            type: 'ANALYZE',
            payload: {
                audioData: state.audioData,
                sampleRate: state.sampleRate,
                params: params,
            }
        }, [state.audioData.buffer]);
    }
    
    function setProcessingState(isProcessing, text = '') {
        state.isProcessing = isProcessing;
        dom.loaderOverlay.classList.toggle('hidden', !isProcessing);
        dom.progressText.textContent = text;
        [dom.thresholdSlider, dom.chunkSizeSlider, dom.minSilenceSlider, dom.paddingSlider, dom.exportButton]
            .forEach(el => el.disabled = isProcessing);
    }
    
    function drawHistogram(volumes) {
        const { width, height } = dom.histogramCanvas;
        histogramCtx.clearRect(0, 0, width, height);
        const barWidth = width / volumes.length;
        const threshold = parseFloat(dom.thresholdSlider.value);
        
        const gradient = histogramCtx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, 'rgba(10, 132, 255, 0.8)');
        gradient.addColorStop(1, 'rgba(10, 132, 255, 0.3)');
        const silentColor = 'rgba(255, 80, 80, 0.5)';
        
        for (let i = 0; i < volumes.length; i++) {
            const db = volumes[i];
            const normalizedHeight = (db + 100) / 100; // Assume range -100dB to 0dB
            const barHeight = Math.max(1, normalizedHeight * height);
            histogramCtx.fillStyle = db < threshold ? silentColor : gradient;
            histogramCtx.fillRect(i * barWidth, height - barHeight, barWidth, barHeight);
        }
    }

    function handleTimeUpdate() {
        if (state.soundZones.length === 0 || dom.videoPlayer.paused) return;
        const currentTime = dom.videoPlayer.currentTime;
        const currentZone = state.soundZones[state.currentSoundZoneIndex];
        if (currentTime >= currentZone.end) {
            const nextZoneIndex = state.currentSoundZoneIndex + 1;
            if (nextZoneIndex < state.soundZones.length) {
                state.currentSoundZoneIndex = nextZoneIndex;
                dom.videoPlayer.currentTime = state.soundZones[nextZoneIndex].start;
                dom.videoPlayer.play();
            } else {
                dom.videoPlayer.pause();
                dom.videoPlayer.currentTime = state.soundZones[0].start;
                state.currentSoundZoneIndex = 0;
            }
        }
    }

    async function exportVideo() {
        if (!state.videoFile || state.soundZones.length === 0) {
            alert('書き出すデータがありません。先にファイルを解析してください。');
            return;
        }

        setProcessingState(true, "書き出しの準備中...");
        dom.exportProgress.classList.remove('hidden');

        try {
            await loadFFmpeg();
            const { fetchFile } = window.FFmpegUtil;
            const { name } = state.videoFile;
            const outputName = `clipped-${name.split('.')[0]}.mp4`;

            await ffmpeg.writeFile(name, await fetchFile(state.videoFile));
            
            const filter_complex = state.soundZones
                .map((zone, i) => `[0:v]trim=start=${zone.start}:end=${zone.end},setpts=PTS-STARTPTS[v${i}];[0:a]atrim=start=${zone.start}:end=${zone.end},asetpts=PTS-STARTPTS[a${i}];`)
                .join('');
            const concat_filter = state.soundZones
                .map((_, i) => `[v${i}][a${i}]`)
                .join('') + `concat=n=${state.soundZones.length}:v=1:a=1[outv][outa]`;
            
            await ffmpeg.exec(['-i', name, '-filter_complex', `${filter_complex}${concat_filter}`, '-map', '[outv]', '-map', '[outa]', outputName]);
            
            const data = await ffmpeg.readFile(outputName);
            const blob = new Blob([data.buffer], { type: 'video/mp4' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = outputName;
            a.click();
            URL.revokeObjectURL(url);

            await ffmpeg.deleteFile(name);
            await ffmpeg.deleteFile(outputName);
        } catch (error) {
            console.error('書き出し中にエラーが発生しました:', error);
            alert('動画の書き出しに失敗しました。');
        } finally {
            setProcessingState(false);
            dom.exportProgress.classList.add('hidden');
        }
    }
    
    // ===================================================================================
    // --- EVENT LISTENERS ---
    // ===================================================================================

    dom.fileDropZone.addEventListener('click', () => dom.fileInput.click());
    dom.fileInput.addEventListener('change', (e) => handleFileSelect(e.target.files[0]));
    dom.fileDropZone.addEventListener('dragover', (e) => { e.preventDefault(); dom.fileDropZone.classList.add('dragover'); });
    dom.fileDropZone.addEventListener('dragleave', () => dom.fileDropZone.classList.remove('dragover'));
    dom.fileDropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dom.fileDropZone.classList.remove('dragover');
        handleFileSelect(e.dataTransfer.files[0]);
    });
    
    worker.onmessage = (e) => {
        const { type, payload } = e.data;
        if (type === 'PROGRESS') {
            setProcessingState(true, payload.text);
        } else if (type === 'HISTOGRAM_DATA') {
            state.audioData = new Float32Array(payload.audioDataBuffer);
            drawHistogram(payload.volumes);
        } else if (type === 'ANALYSIS_COMPLETE') {
            state.soundZones = payload.soundZones;
            setProcessingState(false);
            if (state.soundZones.length > 0) {
                dom.videoPlayer.currentTime = state.soundZones[0].start;
                state.currentSoundZoneIndex = 0;
            } else {
                alert('解析の結果、音声区間が見つかりませんでした。');
            }
        }
    };

    dom.exportButton.addEventListener('click', exportVideo);
    
    const sliders = [
        { el: dom.thresholdSlider, elValue: dom.thresholdValue, unit: ' dB' },
        { el: dom.chunkSizeSlider, elValue: dom.chunkSizeValue, unit: ' ms' },
        { el: dom.minSilenceSlider, elValue: dom.minSilenceValue, unit: ' ms' },
        { el: dom.paddingSlider, elValue: dom.paddingValue, unit: ' ms' },
    ];
    sliders.forEach(({el, elValue, unit}) => {
        el.addEventListener('input', () => { elValue.textContent = `${el.value}${unit}`; });
        el.addEventListener('change', triggerAnalysis);
    });
    
    dom.videoPlayer.addEventListener('timeupdate', handleTimeUpdate);
    dom.videoPlayer.addEventListener('seeking', () => {
        const currentTime = dom.videoPlayer.currentTime;
        const zoneIndex = state.soundZones.findIndex(z => currentTime >= z.start && currentTime < z.end);
        state.currentSoundZoneIndex = (zoneIndex !== -1) ? zoneIndex : 0;
    });

    </script>
</body>
</html>
