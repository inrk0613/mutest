<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Silence Cutter — 無音カット（ブラウザ完結）</title>
<style>
  /* ====== シンプルで洗練された UI (Apple的な余白とタイポグラフィ) ====== */
  :root{
    --bg:#0f1720; --card:#0b1220; --muted:#9aa6b2; --accent:#0ea5a4;
    --glass: rgba(255,255,255,0.03);
    --radius:14px;
    --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", "Meiryo", sans-serif;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071021 0%, #071526 60%);font-family:var(--font-sans);color:#e6eef6}
  .wrap{max-width:1100px;margin:32px auto;padding:28px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:16px;box-shadow:0 8px 30px rgba(5,8,15,0.7)}
  header{display:flex;gap:18px;align-items:center;margin-bottom:18px}
  .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--accent),#2563eb);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:18px}
  h1{margin:0;font-size:20px}
  p.lead{margin:2px 0 0;color:var(--muted);font-size:13px}
  .main{display:grid;grid-template-columns: 1fr 420px;gap:20px;margin-top:18px}
  @media(max-width:980px){.main{grid-template-columns:1fr}}
  .card{background:var(--card);padding:16px;border-radius:12px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.02)}
  .dropzone{border:2px dashed rgba(255,255,255,0.04);padding:20px;border-radius:10px;text-align:center;cursor:pointer}
  .dropzone.dragover{border-color:rgba(14,165,164,0.8);box-shadow:0 6px 24px rgba(14,165,164,0.06)}
  input[type=file]{display:none}
  .controls{display:flex;flex-direction:column;gap:12px}
  label.range{display:flex;flex-direction:column;gap:6px}
  .rangeRow{display:flex;gap:12px;align-items:center}
  .rangeRow input[type=range]{flex:1}
  .val{min-width:72px;text-align:right;color:var(--muted);font-size:13px}
  canvas.hist{width:100%;height:120px;border-radius:8px;background:var(--glass);display:block}
  .progress{height:8px;background:rgba(255,255,255,0.04);border-radius:999px;overflow:hidden}
  .progress > i{display:block;height:100%;width:0;background:linear-gradient(90deg,var(--accent),#60a5fa)}
  .small{font-size:12px;color:var(--muted)}
  .muted{color:var(--muted)}
  .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:10px;background:linear-gradient(90deg,var(--accent),#60a5fa);color:#012;cursor:pointer;border:none;font-weight:700}
  .outline{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
  .list{max-height:200px;overflow:auto;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01)}
  .meta{display:flex;justify-content:space-between;align-items:center;gap:12px}
  .spinner{width:28px;height:28px;border-radius:50%;border:3px solid rgba(255,255,255,0.08);border-top-color:var(--accent);animation:spin 1s linear infinite}
  @keyframes spin{to{transform:rotate(360deg)}}
  footer{margin-top:18px;color:var(--muted);font-size:13px;text-align:right}
  .seglist{font-family:monospace;font-size:13px}
  video{width:100%;border-radius:10px;background:black;display:block}
</style>
</head>
<body>
<div class="wrap" role="application" aria-label="Silence Cutter">
  <header>
    <div class="logo">SC</div>
    <div>
      <h1>Silence Cutter</h1>
      <p class="lead">動画の無音部分をブラウザ内で自動検出・プレビュー（ファイルは外部送信しません）</p>
    </div>
  </header>

  <div class="main">
    <!-- LEFT: ツールと結果 -->
    <div class="card" id="left">
      <div class="dropzone" id="dropzone" tabindex="0" role="button" aria-label="動画を追加">
        <div style="font-weight:700">ここに動画をドロップ</div>
        <div class="small muted">または <button id="pickBtn" class="outline btn">ファイルを選択</button></div>
        <input type="file" id="fileInput" accept="video/mp4,video/webm,video/quicktime,video/*">
      </div>

      <div style="margin-top:12px;display:flex;gap:12px;align-items:center;">
        <div class="meta">
          <div class="small muted">解析ステータス</div>
        </div>
        <div style="flex:1">
          <div class="progress" aria-hidden="true"><i id="progressBar"></i></div>
        </div>
        <div id="statusText" class="small muted">待機中</div>
      </div>

      <div style="margin-top:14px" class="controls">
        <label class="range">
          <div class="rangeRow"><div>Threshold (dB)</div><div class="val" id="thVal">-50 dB</div></div>
          <input id="threshold" type="range" min="-80" max="-12" step="1" value="-50">
        </label>

        <label class="range">
          <div class="rangeRow"><div>Chunk (ms)</div><div class="val" id="chunkVal">50 ms</div></div>
          <input id="chunk" type="range" min="10" max="200" step="5" value="50">
        </label>

        <label class="range">
          <div class="rangeRow"><div>Min Silence (ms)</div><div class="val" id="minSilenceVal">300 ms</div></div>
          <input id="minSilence" type="range" min="50" max="2000" step="50" value="300">
        </label>

        <label class="range">
          <div class="rangeRow"><div>Padding (ms)</div><div class="val" id="padVal">150 ms</div></div>
          <input id="padding" type="range" min="0" max="1000" step="10" value="150">
        </label>

        <div>
          <canvas id="histogram" class="hist" aria-label="音量ヒストグラム"></canvas>
          <div class="small muted" style="margin-top:6px">ヒストグラムはチャンク毎の dB 分布を示します</div>
        </div>

        <div style="display:flex;gap:10px;align-items:center;margin-top:6px">
          <button id="analyzeBtn" class="btn">解析を実行</button>
          <button id="clearBtn" class="outline btn">クリア</button>
          <div style="margin-left:auto" id="analyzeSpinner" hidden><div class="spinner" aria-hidden="true"></div></div>
        </div>
      </div>

      <div style="margin-top:14px">
        <div class="small muted">無音区間（開始 → 終了）</div>
        <div class="list seglist" id="silenceList">—</div>
      </div>

      <div style="margin-top:10px">
        <div class="small muted">音声あり区間</div>
        <div class="list seglist" id="soundList">—</div>
      </div>
    </div>

    <!-- RIGHT: プレビュー領域 -->
    <div class="card">
      <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px">
        <div style="flex:1"><strong id="filename">ファイル未選択</strong><div class="small muted" id="filemeta"></div></div>
        <div style="text-align:right"><button id="playPreview" class="btn outline">プレビュー再生</button></div>
      </div>

      <video id="video" controls playsinline></video>

      <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
        <div class="small muted">再生モード:</div>
        <div class="small"> <label><input type="checkbox" id="skipSilence" checked> 無音をスキップして再生</label></div>
      </div>

      <div style="margin-top:10px" class="small muted">ログ</div>
      <pre id="log" style="height:120px;overflow:auto;background:rgba(0,0,0,0.25);padding:8px;border-radius:8px;color:#dff6fb"></pre>
    </div>
  </div>

  <footer>静的ホスティング対応 — Client-only. &nbsp;データはどこにも送られません。</footer>
</div>

<script type="module">
/**
 * Silence Cutter — main (TypeScript-style JSDoc, transpiled JS for browser)
 *
 * 実装ノート:
 * - 音声データのデコードは AudioContext.decodeAudioData（非同期）で行い、
 *   Float32Array を WebWorker に transfer して解析（RMS/dB計算、チャンク処理）。
 * - Worker はチャンクごとの RMS を計算して dB 配列を返す。メインスレッドはヒストグラム描画と無音区間の生成を担当。
 * - プレビューは precomputed の soundSegments を使って timeupdate でシークすることで無音をスキップ（極力シームレス）。
 *
 * 注: 厳密なWASM最適化は今回は未実装。Worker内の処理は TypedArray を使い最小コピーで高速化しています。
 */

/* ======= ユーティリティ型/関数 ======= */
/** 秒数を hh:mm:ss.mmm 形式に整形 */
function fmtTime(s) {
  if (!isFinite(s)) return "NaN";
  const ms = Math.floor((s - Math.floor(s)) * 1000);
  const sec = Math.floor(s % 60);
  const min = Math.floor((s / 60) % 60);
  const hr = Math.floor(s / 3600);
  return `${hr}:${String(min).padStart(2,"0")}:${String(sec).padStart(2,"0")}.${String(ms).padStart(3,"0")}`;
}

/** log 出力 */
const logEl = document.getElementById("log");
function log(...args) {
  const t = new Date().toLocaleTimeString();
  logEl.textContent += `[${t}] ${args.join(" ")}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}

/* ======= DOM 要素 ======= */
const dropzone = document.getElementById("dropzone");
const fileInput = document.getElementById("fileInput");
const pickBtn = document.getElementById("pickBtn");
const analyzeBtn = document.getElementById("analyzeBtn");
const clearBtn = document.getElementById("clearBtn");
const analyzeSpinner = document.getElementById("analyzeSpinner");
const statusText = document.getElementById("statusText");
const progressBar = document.getElementById("progressBar");
const histogram = document.getElementById("histogram");
const thresholdEl = document.getElementById("threshold");
const thVal = document.getElementById("thVal");
const chunkEl = document.getElementById("chunk");
const chunkVal = document.getElementById("chunkVal");
const minSilenceEl = document.getElementById("minSilence");
const minSilenceVal = document.getElementById("minSilenceVal");
const paddingEl = document.getElementById("padding");
const padVal = document.getElementById("padVal");
const silenceList = document.getElementById("silenceList");
const soundList = document.getElementById("soundList");
const videoEl = document.getElementById("video");
const filenameEl = document.getElementById("filename");
const filemetaEl = document.getElementById("filemeta");
const playPreviewBtn = document.getElementById("playPreview");
const skipSilenceCheckbox = document.getElementById("skipSilence");

/* ======= 初期 UI 値表示 ======= */
function updateUIValues() {
  thVal.textContent = `${thresholdEl.value} dB`;
  chunkVal.textContent = `${chunkEl.value} ms`;
  minSilenceVal.textContent = `${minSilenceEl.value} ms`;
  padVal.textContent = `${paddingEl.value} ms`;
}
updateUIValues();
thresholdEl.addEventListener("input", updateUIValues);
chunkEl.addEventListener("input", updateUIValues);
minSilenceEl.addEventListener("input", updateUIValues);
paddingEl.addEventListener("input", updateUIValues);

/* ======= ドラッグ＆ドロップ / ファイル選択 ======= */
pickBtn.addEventListener("click", ()=> fileInput.click());
dropzone.addEventListener("click", ()=> fileInput.click());
fileInput.addEventListener("change", (e)=> {
  const f = e.target.files[0];
  if (f) handleFile(f);
});

["dragenter","dragover"].forEach(ev=>{
  dropzone.addEventListener(ev, (e)=>{
    e.preventDefault(); e.stopPropagation();
    dropzone.classList.add("dragover");
  });
});
["dragleave","drop"].forEach(ev=>{
  dropzone.addEventListener(ev, (e)=>{
    e.preventDefault(); e.stopPropagation();
    dropzone.classList.remove("dragover");
  });
});
dropzone.addEventListener("drop", (e)=>{
  const f = e.dataTransfer.files[0];
  if (f) handleFile(f);
});

/* ======= 状態変数 ======= */
let currentFile = null;
let audioBufferGlobal = null; // decoded AudioBuffer
let sampleRate = 48000;
let worker = null;
let lastRmsDbArray = null;
let soundSegments = []; // [{start,end}]
let silenceSegments = []; // [{start,end}]
let analyzing = false;
let autoSeekHandler = null;

/* ======= Worker 作成（Blob URL を使う - 単一ファイルに収めるため） ======= */
function createWorker() {
  // Worker スクリプト（ES6）を文字列で作成
  const workerCode = `
  self.onmessage = function(ev) {
    const msg = ev.data;
    if (msg.cmd === 'analyze') {
      const { channelData, sampleRate, chunkMs } = msg;
      // channelData: Array of ArrayBuffer (Float32Array.buffer for each channel)
      const channels = channelData.map(b => new Float32Array(b));
      const length = channels[0].length;
      const framesPerChunk = Math.max(1, Math.floor(sampleRate * (chunkMs/1000)));
      const nChunks = Math.ceil(length / framesPerChunk);
      const rmsDb = new Float32Array(nChunks);
      // for efficiency, precompute channel count
      const chCount = channels.length;
      for (let cIdx = 0; cIdx < nChunks; cIdx++) {
        const start = cIdx * framesPerChunk;
        const end = Math.min(length, start + framesPerChunk);
        let sumSq = 0.0;
        let samples = 0;
        // sum across channels
        for (let ch = 0; ch < chCount; ch++){
          const chArr = channels[ch];
          for (let i = start; i < end; i++){
            const s = chArr[i];
            sumSq += s * s;
            samples++;
          }
        }
        // compute RMS
        const meanSq = samples > 0 ? (sumSq / samples) : 0;
        const rms = Math.sqrt(meanSq);
        // convert to dBFS (reference 1.0)
        const db = rms > 0 ? (20 * Math.log10(rms)) : -200.0;
        rmsDb[cIdx] = db;
        // progress notification every 256 chunks
        if ((cIdx & 255) === 0) {
          self.postMessage({ type: 'progress', progress: cIdx / nChunks });
        }
      }
      self.postMessage({ type:'done', rmsDb: rmsDb.buffer }, [rmsDb.buffer]);
    }
  };
  `;
  const blob = new Blob([workerCode], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  return new Worker(url);
}

/* ======= ファイル処理フロー ======= */
async function handleFile(file) {
  clearAll();
  currentFile = file;
  filenameEl.textContent = file.name;
  filemetaEl.textContent = `${(file.size/1024/1024).toFixed(2)} MB`;
  log("ファイル選択:", file.name);
  // video 要素にオブジェクトURLセット（プレビュー用）
  const url = URL.createObjectURL(file);
  videoEl.src = url;

  // decode audio
  try {
    statusText.textContent = "デコード中...";
    analyzing = true;
    analyzeSpinner.hidden = false;
    progressBar.style.width = "6%";
    // read as ArrayBuffer
    const ab = await file.arrayBuffer();
    // create AudioContext and decode
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const decoded = await audioCtx.decodeAudioData(ab.slice(0)); // async
    audioBufferGlobal = decoded;
    sampleRate = decoded.sampleRate;
    log("デコード完了. duration:", decoded.duration.toFixed(2), "s, sampleRate:", decoded.sampleRate);
    statusText.textContent = "解析準備完了";
    progressBar.style.width = "12%";
    analyzing = false;
    analyzeSpinner.hidden = true;
  } catch (err) {
    console.error(err);
    statusText.textContent = "デコード失敗";
    analyzeSpinner.hidden = true;
    log("エラー: デコードに失敗しました。対応フォーマットか確認してください。", err.message || err);
    return;
  }
}

/* ======= 解析実行 ======= */
async function analyze() {
  if (!audioBufferGlobal) { alert("先に動画を選択してください"); return; }
  // UI 状態
  analyzeBtn.disabled = true; clearBtn.disabled = true; analyzeSpinner.hidden = false;
  statusText.textContent = "解析中...";
  progressBar.style.width = "20%";
  log("解析開始");

  // パラメータ
  const thresholdDb = Number(thresholdEl.value);
  const chunkMs = Number(chunkEl.value);
  const minSilenceMs = Number(minSilenceEl.value);
  const paddingMs = Number(paddingEl.value);

  // prepare channel data (transferable)
  const chCount = audioBufferGlobal.numberOfChannels || 1;
  const channelData = [];
  for (let c=0;c<chCount;c++){
    // copy to Float32Array to ensure contiguous buffer
    const arr = audioBufferGlobal.getChannelData(c);
    // create a copy (Float32Array) to be transferable
    const copy = new Float32Array(arr.length);
    copy.set(arr);
    channelData.push(copy.buffer);
  }

  // create worker and send data
  worker && worker.terminate();
  worker = createWorker();
  worker.onmessage = function(ev) {
    const msg = ev.data;
    if (msg.type === 'progress') {
      const p = Math.min(0.95, 0.2 + msg.progress*0.75);
      progressBar.style.width = (p*100)+"%";
      statusText.textContent = `解析中... ${(p*100).toFixed(0)}%`;
    } else if (msg.type === 'done') {
      progressBar.style.width = "100%";
      statusText.textContent = "解析完了";
      analyzeSpinner.hidden = true;
      analyzeBtn.disabled = false; clearBtn.disabled = false;
      // msg.rmsDb is transferred ArrayBuffer
      const dbArr = new Float32Array(msg.rmsDb);
      lastRmsDbArray = dbArr;
      log("RMS->dB チャンク数:", dbArr.length);
      // post-process to produce silence/sound segments
      const {soundSegs, silenceSegs} = generateSegmentsFromDbArray(dbArr, {
        chunkMs, thresholdDb, minSilenceMs, paddingMs, totalDuration: audioBufferGlobal.duration
      });
      soundSegments = soundSegs;
      silenceSegments = silenceSegs;
      renderSegments();
      drawHistogram(dbArr);
      log("無音セグメント数:", silenceSegs.length, "音声セグメント数:", soundSegs.length);
    }
  };

  // send heavy data with transfer to worker
  worker.postMessage({ cmd:'analyze', channelData, sampleRate, chunkMs }, channelData);
}

/* ======= DB配列 -> セグメント生成ロジック ======= */
/**
 * @param {Float32Array} dbArr
 * @param {Object} opts
 * @returns {{soundSegs:Array, silenceSegs:Array}}
 */
function generateSegmentsFromDbArray(dbArr, opts) {
  const { chunkMs, thresholdDb, minSilenceMs, paddingMs, totalDuration } = opts;
  const n = dbArr.length;
  // bool array: isSilent
  const isSilent = new Uint8Array(n);
  for (let i=0;i<n;i++){
    isSilent[i] = dbArr[i] < thresholdDb ? 1 : 0;
  }
  // merge contiguous silent chunks to intervals (in ms)
  const chunksToMs = (i) => i * chunkMs;
  const silenceIntervals = [];
  let i=0;
  while (i < n) {
    if (isSilent[i]) {
      const startChunk = i;
      while (i<n && isSilent[i]) i++;
      const endChunk = i-1;
      const startMs = startChunk * chunkMs;
      const endMs = (endChunk+1) * chunkMs;
      const dur = endMs - startMs;
      if (dur >= minSilenceMs) {
        // apply padding
        const s = Math.max(0, (startMs - paddingMs)/1000);
        const e = Math.min(totalDuration, (endMs + paddingMs)/1000);
        silenceIntervals.push({start:s, end:e});
      }
    } else i++;
  }
  // now compute sound intervals as complement
  const soundIntervals = [];
  let cur = 0.0;
  silenceIntervals.sort((a,b)=>a.start-b.start);
  for (const sil of silenceIntervals) {
    if (cur < sil.start) {
      soundIntervals.push({start:cur, end: sil.start});
    }
    cur = Math.max(cur, sil.end);
  }
  if (cur < totalDuration) soundIntervals.push({start:cur, end: totalDuration});
  return { soundSegs: soundIntervals, silenceSegs: silenceIntervals };
}

/* ======= ヒストグラム描画 ======= */
function drawHistogram(dbArr) {
  const canvas = histogram;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = canvas.clientWidth * dpr;
  canvas.height = canvas.clientHeight * dpr;
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // bucketize
  const buckets = 60;
  const minDb = -100, maxDb = 0;
  const counts = new Uint32Array(buckets);
  for (let i=0;i<dbArr.length;i++){
    const v = Math.max(minDb, Math.min(maxDb, dbArr[i]));
    const idx = Math.floor(((v - minDb) / (maxDb - minDb)) * (buckets-1));
    counts[idx]++;
  }
  const maxC = Math.max(1, Math.max(...counts));
  // draw bars
  const w = canvas.width, h = canvas.height;
  const barW = w / buckets;
  for (let b=0;b<buckets;b++){
    const c = counts[b];
    const hh = (c / maxC) * (h*0.9);
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(b*barW, h-hh, Math.max(1,barW-1), hh);
  }
  // axis labels
  ctx.fillStyle = "rgba(255,255,255,0.12)";
  ctx.font = `${12*dpr}px system-ui`;
  ctx.fillText(`${Math.round(-100)} dB`, 4*dpr, 14*dpr);
  ctx.fillText(`${Math.round(0)} dB`, w - 28*dpr, 14*dpr);
}

/* ======= セグメント表示 ======= */
function renderSegments() {
  if (silenceSegments.length===0) {
    silenceList.textContent = "検出なし";
  } else {
    silenceList.innerHTML = silenceSegments.map(s=>`${fmtTime(s.start)} → ${fmtTime(s.end)}`).join("\n");
  }
  if (soundSegments.length===0) {
    soundList.textContent = "検出なし";
  } else {
    soundList.innerHTML = soundSegments.map((s,i)=>`[${String(i).padStart(2,"0")}] ${fmtTime(s.start)} → ${fmtTime(s.end)}`).join("\n");
  }
}

/* ======= プレビュー（無音スキップ） ======= */
playPreviewBtn.addEventListener("click", ()=>{
  if (!videoEl.src) { alert("先に動画を選択してください"); return; }
  if (skipSilenceCheckbox.checked && soundSegments.length===0) {
    alert("解析結果がありません。先に解析を実行してください（左側の解析ボタン）。");
    return;
  }
  // toggle play/pause
  if (videoEl.paused) {
    // start from first sound segment or from current time
    startPreview();
  } else {
    stopPreview();
  }
});

function startPreview(){
  playPreviewBtn.textContent = "停止";
  videoEl.play();
  if (skipSilenceCheckbox.checked) {
    setupAutoSkip();
  } else {
    removeAutoSkip();
  }
}

function stopPreview(){
  playPreviewBtn.textContent = "プレビュー再生";
  videoEl.pause();
  removeAutoSkip();
}

function setupAutoSkip() {
  removeAutoSkip();
  let idx = findSegmentIndexAtTime(videoEl.currentTime);
  if (idx < 0) idx = 0;
  // if current time is inside silence, jump to next sound
  if (idx >= soundSegments.length) { videoEl.currentTime = soundSegments.length?soundSegments[soundSegments.length-1].start:0; return; }
  // ensure we start inside a sound segment
  if (videoEl.currentTime < soundSegments[idx].start) videoEl.currentTime = soundSegments[idx].start + 0.001;
  autoSeekHandler = function () {
    const t = videoEl.currentTime;
    const seg = soundSegments[idx];
    if (!seg) return;
    // if beyond this segment, advance
    if (t >= seg.end - 0.05) {
      idx++;
      if (idx >= soundSegments.length) {
        // end
        stopPreview();
      } else {
        videoEl.currentTime = Math.max(soundSegments[idx].start + 0.001, soundSegments[idx].start);
      }
    }
  };
  videoEl.addEventListener("timeupdate", autoSeekHandler);
}

function removeAutoSkip(){
  if (autoSeekHandler) {
    videoEl.removeEventListener("timeupdate", autoSeekHandler);
    autoSeekHandler = null;
  }
}

/** 現在時刻が入っている sound segment の index を返す（ない場合は -1） */
function findSegmentIndexAtTime(t) {
  for (let i=0;i<soundSegments.length;i++){
    const s = soundSegments[i];
    if (t >= s.start && t < s.end) return i;
    if (t < s.start) return i; // next segment index
  }
  return soundSegments.length;
}

/* ======= クリア ======= */
function clearAll(){
  currentFile = null; audioBufferGlobal = null; lastRmsDbArray = null;
  soundSegments = []; silenceSegments = [];
  filenameEl.textContent = "ファイル未選択";
  filemetaEl.textContent = "";
  silenceList.textContent = "—";
  soundList.textContent = "—";
  videoEl.removeAttribute("src"); videoEl.load();
  progressBar.style.width = "0%";
  statusText.textContent = "待機中";
  log("クリアしました");
}

/* ======= UI イベントバインディング ======= */
analyzeBtn.addEventListener("click", ()=> {
  analyze().catch(err=>{ console.error(err); analyzeSpinner.hidden=true; analyzeBtn.disabled=false; statusText.textContent='エラー'; log('解析中にエラー', err.message||err); });
});
clearBtn.addEventListener("click", ()=> clearAll());

/* 終了時クリーンアップ */
window.addEventListener("unload", ()=> {
  worker && worker.terminate();
});

/* 初期ログ */
log("Ready. ファイルをドロップするか「ファイルを選択」を押してください。");
</script>
</body>
</html>
