<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Silence Cutter — 無音カット（ブラウザ完結）</title>
<style>
  /* ====== シンプルで洗練された UI (Apple的な余白とタイポグラフィ) ====== */
  :root{
    --bg:#0f1720; --card:#0b1220; --muted:#9aa6b2; --accent:#0ea5a4;
    --glass: rgba(255,255,255,0.03);
    --radius:14px;
    --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", "Meiryo", sans-serif;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071021 0%, #071526 60%);font-family:var(--font-sans);color:#e6eef6}
  .wrap{max-width:1100px;margin:32px auto;padding:28px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:16px;box-shadow:0 8px 30px rgba(5,8,15,0.7)}
  header{display:flex;gap:18px;align-items:center;margin-bottom:18px}
  .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--accent),#2563eb);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:18px}
  h1{margin:0;font-size:20px}
  p.lead{margin:2px 0 0;color:var(--muted);font-size:13px}
  .main{display:grid;grid-template-columns: 1fr 420px;gap:20px;margin-top:18px}
  @media(max-width:980px){.main{grid-template-columns:1fr}}
  .card{background:var(--card);padding:16px;border-radius:12px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.02)}
  .dropzone{border:2px dashed rgba(255,255,255,0.04);padding:20px;border-radius:10px;text-align:center;cursor:pointer}
  .dropzone.dragover{border-color:rgba(14,165,164,0.8);box-shadow:0 6px 24px rgba(14,165,164,0.06)}
  input[type=file]{display:none}
  .controls{display:flex;flex-direction:column;gap:12px;transition: opacity 0.3s ease}
  .controls.disabled{opacity:0.4;pointer-events:none}
  label.range{display:flex;flex-direction:column;gap:6px}
  .rangeRow{display:flex;gap:12px;align-items:center}
  .rangeRow input[type=range]{flex:1}
  .val{min-width:72px;text-align:right;color:var(--muted);font-size:13px}
  canvas.hist{width:100%;height:120px;border-radius:8px;background:var(--glass);display:block}
  .progress{height:8px;background:rgba(255,255,255,0.04);border-radius:999px;overflow:hidden}
  .progress > i{display:block;height:100%;width:0;background:linear-gradient(90deg,var(--accent),#60a5fa);transition: width 0.4s ease}
  .small{font-size:12px;color:var(--muted)}
  .muted{color:var(--muted)}
  .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:10px;background:linear-gradient(90deg,var(--accent),#60a5fa);color:#012;cursor:pointer;border:none;font-weight:700;transition: all 0.2s ease}
  .btn:disabled{cursor:not-allowed;filter:grayscale(60%);opacity:0.7}
  .outline{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
  .outline:hover:not(:disabled){background:rgba(255,255,255,0.03)}
  .btn:hover:not(:disabled){transform:translateY(-1px);box-shadow:0 4px 12px rgba(14,165,164,0.1)}
  .list{max-height:200px;overflow:auto;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01)}
  .meta{display:flex;justify-content:space-between;align-items:center;gap:12px}
  .spinner{width:28px;height:28px;border-radius:50%;border:3px solid rgba(255,255,255,0.08);border-top-color:var(--accent);animation:spin 1s linear infinite}
  @keyframes spin{to{transform:rotate(360deg)}}
  footer{margin-top:18px;color:var(--muted);font-size:13px;text-align:right}
  .seglist{font-family:monospace;font-size:13px}
  video{width:100%;border-radius:10px;background:black;display:block}
</style>
</head>
<body>
<div class="wrap" role="application" aria-label="Silence Cutter">
  <header>
    <div class="logo">SC</div>
    <div>
      <h1>Silence Cutter</h1>
      <p class="lead">動画の無音部分をブラウザ内で自動検出・プレビュー（ファイルは外部送信しません）</p>
    </div>
  </header>

  <div class="main">
    <!-- LEFT: ツールと結果 -->
    <div class="card" id="left">
      <div class="dropzone" id="dropzone" tabindex="0" role="button" aria-label="動画を追加">
        <div style="font-weight:700">ここに動画をドロップ</div>
        <div class="small muted">または <button id="pickBtn" class="outline btn">ファイルを選択</button></div>
        <input type="file" id="fileInput" accept="video/mp4,video/webm,video/quicktime,video/*">
      </div>

      <div style="margin-top:12px;display:flex;gap:12px;align-items:center;">
        <div class="meta">
          <div class="small muted">解析ステータス</div>
        </div>
        <div style="flex:1">
          <div class="progress" aria-hidden="true"><i id="progressBar"></i></div>
        </div>
        <div id="statusText" class="small muted">待機中</div>
      </div>

      <div style="margin-top:14px" class="controls disabled" id="controls">
        <label class="range">
          <div class="rangeRow"><div>Threshold (dB)</div><div class="val" id="thVal">-50 dB</div></div>
          <input id="threshold" type="range" min="-80" max="-12" step="1" value="-50">
        </label>

        <label class="range">
          <div class="rangeRow"><div>Chunk (ms)</div><div class="val" id="chunkVal">50 ms</div></div>
          <input id="chunk" type="range" min="10" max="200" step="5" value="50">
        </label>

        <label class="range">
          <div class="rangeRow"><div>Min Silence (ms)</div><div class="val" id="minSilenceVal">300 ms</div></div>
          <input id="minSilence" type="range" min="50" max="2000" step="50" value="300">
        </label>

        <label class="range">
          <div class="rangeRow"><div>Padding (ms)</div><div class="val" id="padVal">150 ms</div></div>
          <input id="padding" type="range" min="0" max="1000" step="10" value="150">
        </label>

        <div>
          <canvas id="histogram" class="hist" aria-label="音量ヒストグラム"></canvas>
          <div class="small muted" style="margin-top:6px">ヒストグラムはチャンク毎の dB 分布を示します</div>
        </div>

        <div style="display:flex;gap:10px;align-items:center;margin-top:6px">
          <button id="analyzeBtn" class="btn" disabled>解析を実行</button>
          <button id="clearBtn" class="outline btn">クリア</button>
          <div style="margin-left:auto" id="analyzeSpinner" hidden><div class="spinner" aria-hidden="true"></div></div>
        </div>
      </div>

      <div style="margin-top:14px">
        <div class="small muted">無音区間（開始 → 終了）</div>
        <div class="list seglist" id="silenceList">—</div>
      </div>

      <div style="margin-top:10px">
        <div class="small muted">音声あり区間</div>
        <div class="list seglist" id="soundList">—</div>
      </div>
    </div>

    <!-- RIGHT: プレビュー領域 -->
    <div class="card">
      <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px">
        <div style="flex:1"><strong id="filename">ファイル未選択</strong><div class="small muted" id="filemeta"></div></div>
        <div style="text-align:right"><button id="playPreview" class="btn outline">プレビュー再生</button></div>
      </div>

      <video id="video" controls playsinline></video>

      <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
        <div class="small muted">再生モード:</div>
        <div class="small"> <label><input type="checkbox" id="skipSilence" checked> 無音をスキップして再生</label></div>
      </div>

      <div style="margin-top:10px" class="small muted">ログ</div>
      <pre id="log" style="height:120px;overflow:auto;background:rgba(0,0,0,0.25);padding:8px;border-radius:8px;color:#dff6fb"></pre>
    </div>
  </div>

  <footer>静的ホスティング対応 — Client-only. &nbsp;データはどこにも送られません。</footer>
</div>

<script type="module">
/**
 * Silence Cutter — main (TypeScript-style JSDoc, transpiled JS for browser)
 *
 * 実装ノート:
 * - [修正] 動画ファイルのオーディオデコードは、decodeAudioData の直接使用を廃止。
 *   代わりに OfflineAudioContext と MediaElementAudioSourceNode を使用し、
 *   ブラウザの動画デコード能力を活用して堅牢にオーディオトラックを抽出する方式に変更。
 * - Float32Array を WebWorker に transfer して解析（RMS/dB計算、チャンク処理）するコアロジックは維持。
 * - Worker はチャンクごとの RMS を計算して dB 配列を返す。メインスレッドはヒストグラム描画と無音区間の生成を担当。
 * - プレビューは precomputed の soundSegments を使って timeupdate でシークすることで無音をスキップ。
 *
 * 注: 厳密なWASM最適化は今回は未実装。Worker内の処理は TypedArray を使い最小コピーで高速化しています。
 */

/* ======= ユーティリティ型/関数 ======= */
/** 秒数を hh:mm:ss.mmm 形式に整形 */
function fmtTime(s) {
  if (!isFinite(s)) return "NaN";
  const ms = Math.floor((s - Math.floor(s)) * 1000);
  const sec = Math.floor(s % 60);
  const min = Math.floor((s / 60) % 60);
  const hr = Math.floor(s / 3600);
  return `${hr}:${String(min).padStart(2,"0")}:${String(sec).padStart(2,"0")}.${String(ms).padStart(3,"0")}`;
}

/** log 出力 */
const logEl = document.getElementById("log");
function log(...args) {
  const t = new Date().toLocaleTimeString();
  logEl.textContent += `[${t}] ${args.join(" ")}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}

/* ======= DOM 要素 ======= */
const dropzone = document.getElementById("dropzone");
const fileInput = document.getElementById("fileInput");
const pickBtn = document.getElementById("pickBtn");
const analyzeBtn = document.getElementById("analyzeBtn");
const clearBtn = document.getElementById("clearBtn");
const controlsEl = document.getElementById("controls");
const analyzeSpinner = document.getElementById("analyzeSpinner");
const statusText = document.getElementById("statusText");
const progressBar = document.getElementById("progressBar");
const histogram = document.getElementById("histogram");
const thresholdEl = document.getElementById("threshold");
const thVal = document.getElementById("thVal");
const chunkEl = document.getElementById("chunk");
const chunkVal = document.getElementById("chunkVal");
const minSilenceEl = document.getElementById("minSilence");
const minSilenceVal = document.getElementById("minSilenceVal");
const paddingEl = document.getElementById("padding");
const padVal = document.getElementById("padVal");
const silenceList = document.getElementById("silenceList");
const soundList = document.getElementById("soundList");
const videoEl = document.getElementById("video");
const filenameEl = document.getElementById("filename");
const filemetaEl = document.getElementById("filemeta");
const playPreviewBtn = document.getElementById("playPreview");
const skipSilenceCheckbox = document.getElementById("skipSilence");

/* ======= 初期 UI 値表示 ======= */
function updateUIValues() {
  thVal.textContent = `${thresholdEl.value} dB`;
  chunkVal.textContent = `${chunkEl.value} ms`;
  minSilenceVal.textContent = `${minSilenceEl.value} ms`;
  padVal.textContent = `${paddingEl.value} ms`;
}
updateUIValues();
thresholdEl.addEventListener("input", updateUIValues);
chunkEl.addEventListener("input", updateUIValues);
minSilenceEl.addEventListener("input", updateUIValues);
paddingEl.addEventListener("input", updateUIValues);

/* ======= ドラッグ＆ドロップ / ファイル選択 ======= */
pickBtn.addEventListener("click", ()=> fileInput.click());
dropzone.addEventListener("click", ()=> fileInput.click());
fileInput.addEventListener("change", (e)=> {
  const f = e.target.files[0];
  if (f) handleFile(f);
});

["dragenter","dragover"].forEach(ev=>{
  dropzone.addEventListener(ev, (e)=>{
    e.preventDefault(); e.stopPropagation();
    dropzone.classList.add("dragover");
  });
});
["dragleave","drop"].forEach(ev=>{
  dropzone.addEventListener(ev, (e)=>{
    e.preventDefault(); e.stopPropagation();
    dropzone.classList.remove("dragover");
  });
});
dropzone.addEventListener("drop", (e)=>{
  const f = e.dataTransfer.files[0];
  if (f) handleFile(f);
});

/* ======= 状態変数 ======= */
let currentFile = null;
let audioBufferGlobal = null; // decoded AudioBuffer
let sampleRate = 48000;
let worker = null;
let lastRmsDbArray = null;
let soundSegments = []; // [{start,end}]
let silenceSegments = []; // [{start,end}]
let autoSeekHandler = null;

/* ======= Worker 作成（Blob URL を使う - 単一ファイルに収めるため） ======= */
function createWorker() {
  const workerCode = `
  self.onmessage = function(ev) {
    const msg = ev.data;
    if (msg.cmd === 'analyze') {
      const { channelData, sampleRate, chunkMs } = msg;
      const channels = channelData.map(b => new Float32Array(b));
      const length = channels[0].length;
      const framesPerChunk = Math.max(1, Math.floor(sampleRate * (chunkMs/1000)));
      const nChunks = Math.ceil(length / framesPerChunk);
      const rmsDb = new Float32Array(nChunks);
      const chCount = channels.length;
      for (let cIdx = 0; cIdx < nChunks; cIdx++) {
        const start = cIdx * framesPerChunk;
        const end = Math.min(length, start + framesPerChunk);
        let sumSq = 0.0;
        let samples = 0;
        for (let ch = 0; ch < chCount; ch++){
          const chArr = channels[ch];
          for (let i = start; i < end; i++){
            const s = chArr[i];
            sumSq += s * s;
          }
        }
        samples = (end - start) * chCount;
        const meanSq = samples > 0 ? (sumSq / samples) : 0;
        const rms = Math.sqrt(meanSq);
        const db = rms > 0 ? (20 * Math.log10(rms)) : -200.0;
        rmsDb[cIdx] = db;
        if ((cIdx & 255) === 0) {
          self.postMessage({ type: 'progress', progress: cIdx / nChunks });
        }
      }
      self.postMessage({ type:'done', rmsDb: rmsDb.buffer }, [rmsDb.buffer]);
    }
  };
  `;
  const blob = new Blob([workerCode], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  return new Worker(url);
}

/* ======= ファイル処理フロー ======= */
async function handleFile(file) {
  clearAll();
  currentFile = file;
  filenameEl.textContent = file.name;
  filemetaEl.textContent = `${(file.size / 1024 / 1024).toFixed(2)} MB`;
  log("ファイル選択:", file.name);

  controlsEl.classList.add("disabled");
  analyzeBtn.disabled = true;
  analyzeSpinner.hidden = false;
  statusText.textContent = "動画ファイルを準備中...";
  progressBar.style.width = "5%";

  const url = URL.createObjectURL(file);
  videoEl.src = url;

  try {
    await new Promise((resolve, reject) => {
      videoEl.onloadedmetadata = resolve;
      videoEl.onerror = () => reject(new Error("動画ファイルの読み込みに失敗しました。対応していないフォーマットの可能性があります。"));
    });

    const duration = videoEl.duration;
    if (!isFinite(duration) || duration === 0) {
      throw new Error("動画の長さ(duration)が取得できませんでした。");
    }

    log("メタデータ読み込み完了. duration:", duration.toFixed(2), "s");
    statusText.textContent = "音声データを抽出中...";
    progressBar.style.width = "10%";

    // OfflineAudioContext を使用して動画から AudioBuffer を抽出
    const audioCtxForExtract = new (window.AudioContext || window.webkitAudioContext)();
    // 一般的な動画は48kHzのサンプルレートが多いため、これを採用
    const targetSampleRate = 48000;
    const offlineCtx = new OfflineAudioContext(
      2, // ステレオで処理
      Math.ceil(duration * targetSampleRate),
      targetSampleRate
    );

    const source = audioCtxForExtract.createMediaElementSource(videoEl);
    source.connect(offlineCtx.destination);

    const renderedBuffer = await offlineCtx.startRendering();
    audioBufferGlobal = renderedBuffer;
    sampleRate = renderedBuffer.sampleRate;
    
    // クリーンアップ
    source.disconnect();
    audioCtxForExtract.close();

    log("音声抽出完了. SampleRate:", sampleRate, "Hz");
    statusText.textContent = "解析準備完了";
    progressBar.style.width = "15%";
    controlsEl.classList.remove("disabled");
    analyzeBtn.disabled = false;

  } catch (err) {
    console.error(err);
    statusText.textContent = "音声抽出に失敗";
    progressBar.style.width = "0%";
    log("エラー:", err.message || "動画から音声の抽出に失敗しました。");
    return;
  } finally {
    analyzeSpinner.hidden = true;
  }
}


/* ======= 解析実行 ======= */
async function analyze() {
  if (!audioBufferGlobal) { alert("先に動画を選択し、音声データの準備が完了するまでお待ちください。"); return; }
  
  analyzeBtn.disabled = true; clearBtn.disabled = true; analyzeSpinner.hidden = false;
  controlsEl.classList.add("disabled");
  statusText.textContent = "解析中...";
  progressBar.style.width = "20%";
  log("解析開始");

  const thresholdDb = Number(thresholdEl.value);
  const chunkMs = Number(chunkEl.value);
  const minSilenceMs = Number(minSilenceEl.value);
  const paddingMs = Number(paddingEl.value);

  const chCount = audioBufferGlobal.numberOfChannels;
  const channelData = [];
  for (let c=0; c<chCount; c++){
    const arr = audioBufferGlobal.getChannelData(c);
    const copy = new Float32Array(arr.length);
    copy.set(arr);
    channelData.push(copy.buffer);
  }

  worker && worker.terminate();
  worker = createWorker();
  worker.onmessage = function(ev) {
    const msg = ev.data;
    if (msg.type === 'progress') {
      const p = Math.min(0.95, 0.2 + msg.progress * 0.75);
      progressBar.style.width = (p * 100) + "%";
      statusText.textContent = `解析中... ${(p * 100).toFixed(0)}%`;
    } else if (msg.type === 'done') {
      progressBar.style.width = "100%";
      statusText.textContent = "解析完了";
      analyzeSpinner.hidden = true;
      analyzeBtn.disabled = false; clearBtn.disabled = false;
      controlsEl.classList.remove("disabled");
      
      const dbArr = new Float32Array(msg.rmsDb);
      lastRmsDbArray = dbArr;
      log("RMS->dB チャンク数:", dbArr.length);
      
      const {soundSegs, silenceSegs} = generateSegmentsFromDbArray(dbArr, {
        chunkMs, thresholdDb, minSilenceMs, paddingMs, totalDuration: audioBufferGlobal.duration
      });
      soundSegments = soundSegs;
      silenceSegments = silenceSegs;
      renderSegments();
      drawHistogram(dbArr);
      log("無音セグメント数:", silenceSegs.length, "音声セグメント数:", soundSegs.length);
    }
  };

  worker.postMessage({ cmd:'analyze', channelData, sampleRate, chunkMs }, channelData);
}

/* ======= DB配列 -> セグメント生成ロジック ======= */
function generateSegmentsFromDbArray(dbArr, opts) {
  const { chunkMs, thresholdDb, minSilenceMs, paddingMs, totalDuration } = opts;
  const n = dbArr.length;
  const isSilent = new Uint8Array(n);
  for (let i=0;i<n;i++){
    isSilent[i] = dbArr[i] < thresholdDb ? 1 : 0;
  }
  
  const chunksToMs = (i) => i * chunkMs;
  const silenceIntervalsRaw = [];
  let i=0;
  while (i < n) {
    if (isSilent[i]) {
      const startChunk = i;
      while (i<n && isSilent[i]) i++;
      const endChunk = i-1;
      const startMs = startChunk * chunkMs;
      const endMs = (endChunk+1) * chunkMs;
      if ((endMs - startMs) >= minSilenceMs) {
        silenceIntervalsRaw.push({start: startMs, end: endMs});
      }
    } else i++;
  }
  
  const silenceIntervals = silenceIntervalsRaw.map(interval => ({
    start: Math.max(0, (interval.start - paddingMs) / 1000),
    end: Math.min(totalDuration, (interval.end + paddingMs) / 1000)
  }));

  const soundIntervals = [];
  let cur = 0.0;
  silenceIntervals.sort((a,b)=>a.start-b.start);
  for (const sil of silenceIntervals) {
    if (cur < sil.start) {
      soundIntervals.push({start:cur, end: sil.start});
    }
    cur = Math.max(cur, sil.end);
  }
  if (cur < totalDuration) soundIntervals.push({start:cur, end: totalDuration});
  return { soundSegs: soundIntervals.filter(s => s.end - s.start > 0.01), silenceSegs: silenceIntervals };
}

/* ======= ヒストグラム描画 ======= */
function drawHistogram(dbArr) {
  const canvas = histogram;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = canvas.clientWidth * dpr;
  canvas.height = canvas.clientHeight * dpr;
  const ctx = canvas.getContext("2d");
  if (!ctx) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const buckets = 60;
  const minDb = -100, maxDb = 0;
  const counts = new Uint32Array(buckets);
  for (const v of dbArr) {
    if (v > minDb) { // -Infinity は除外
        const idx = Math.floor(((Math.min(maxDb, v) - minDb) / (maxDb - minDb)) * (buckets-1));
        counts[idx]++;
    }
  }
  const maxC = Math.max(1, ...counts);
  const w = canvas.width, h = canvas.height;
  const barW = w / buckets;
  ctx.fillStyle = "rgba(14, 165, 164, 0.4)";
  for (let b=0;b<buckets;b++){
    const hh = (counts[b] / maxC) * h;
    ctx.fillRect(b*barW, h-hh, Math.max(1, barW * 0.85), hh);
  }
  
  ctx.fillStyle = "rgba(255,255,255,0.4)";
  ctx.font = `${10*dpr}px var(--font-sans)`;
  ctx.textAlign = "left";
  ctx.fillText(`${minDb} dB`, 4*dpr, 12*dpr);
  ctx.textAlign = "right";
  ctx.fillText(`${maxDb} dB`, w - 4*dpr, 12*dpr);
}

/* ======= セグメント表示 ======= */
function renderSegments() {
  if (silenceSegments.length===0) {
    silenceList.textContent = "検出なし";
  } else {
    silenceList.innerHTML = silenceSegments.map(s=>`${fmtTime(s.start)} → ${fmtTime(s.end)}`).join("\n");
  }
  if (soundSegments.length===0) {
    soundList.textContent = "検出なし";
  } else {
    soundList.innerHTML = soundSegments.map((s,i)=>`[${String(i).padStart(2,"0")}] ${fmtTime(s.start)} → ${fmtTime(s.end)}`).join("\n");
  }
}

/* ======= プレビュー（無音スキップ） ======= */
playPreviewBtn.addEventListener("click", ()=>{
  if (!videoEl.src || !currentFile) { alert("先に動画を選択してください"); return; }
  if (skipSilenceCheckbox.checked && soundSegments.length===0) {
    alert("解析結果がありません。先に解析を実行してください。");
    return;
  }
  if (videoEl.paused) {
    startPreview();
  } else {
    stopPreview();
  }
});
videoEl.addEventListener("play", ()=> playPreviewBtn.textContent = "停止");
videoEl.addEventListener("pause", ()=> playPreviewBtn.textContent = "プレビュー再生");
videoEl.addEventListener("ended", ()=> stopPreview());


function startPreview(){
  videoEl.play();
  if (skipSilenceCheckbox.checked) {
    setupAutoSkip();
  }
}

function stopPreview(){
  videoEl.pause();
  removeAutoSkip();
}

function setupAutoSkip() {
  removeAutoSkip();
  let idx = findSegmentIndexAtTime(videoEl.currentTime);
  if (idx < 0) idx = 0;
  if (idx >= soundSegments.length) {
      if (soundSegments.length > 0) {
        videoEl.currentTime = soundSegments[0].start + 0.01;
      }
      return;
  }
  if (videoEl.currentTime < soundSegments[idx].start || isTimeInSilence(videoEl.currentTime)) {
    videoEl.currentTime = soundSegments[idx].start + 0.01;
  }
  autoSeekHandler = function () {
    const t = videoEl.currentTime;
    const seg = soundSegments[idx];
    if (!seg) { stopPreview(); return; }

    if (t >= seg.end - 0.1) {
      idx++;
      if (idx >= soundSegments.length) {
        stopPreview();
      } else {
        videoEl.currentTime = soundSegments[idx].start + 0.01;
      }
    }
  };
  videoEl.addEventListener("timeupdate", autoSeekHandler);
}

function removeAutoSkip(){
  if (autoSeekHandler) {
    videoEl.removeEventListener("timeupdate", autoSeekHandler);
    autoSeekHandler = null;
  }
}

function isTimeInSilence(t) {
    return silenceSegments.some(s => t >= s.start && t < s.end);
}

function findSegmentIndexAtTime(t) {
  for (let i=0;i<soundSegments.length;i++){
    const s = soundSegments[i];
    if (t >= s.start && t < s.end) return i;
    if (t < s.start) return i;
  }
  return -1; // Not found
}

/* ======= クリア ======= */
function clearAll(){
  stopPreview();
  currentFile = null; audioBufferGlobal = null; lastRmsDbArray = null;
  soundSegments = []; silenceSegments = [];
  filenameEl.textContent = "ファイル未選択";
  filemetaEl.textContent = "";
  silenceList.textContent = "—";
  soundList.textContent = "—";
  if (videoEl.src) {
    URL.revokeObjectURL(videoEl.src);
    videoEl.removeAttribute("src");
    videoEl.load();
  }
  const ctx = histogram.getContext("2d");
  if(ctx) ctx.clearRect(0,0,histogram.width,histogram.height);
  progressBar.style.width = "0%";
  statusText.textContent = "待機中";
  controlsEl.classList.add("disabled");
  analyzeBtn.disabled = true;
  log("クリアしました");
}

/* ======= UI イベントバインディング ======= */
analyzeBtn.addEventListener("click", ()=> {
  analyze().catch(err=>{ 
      console.error(err); 
      analyzeSpinner.hidden=true; 
      analyzeBtn.disabled=false; 
      controlsEl.classList.remove("disabled");
      statusText.textContent='エラー'; 
      log('解析中にエラー', err.message||err); 
  });
});
clearBtn.addEventListener("click", ()=> clearAll());
skipSilenceCheckbox.addEventListener("change", (e)=>{
  if (videoEl.paused) return;
  if (e.target.checked) setupAutoSkip();
  else removeAutoSkip();
});

/* 終了時クリーンアップ */
window.addEventListener("unload", ()=> {
  worker && worker.terminate();
});

/* 初期ログ */
log("Ready. ファイルをドロップするか「ファイルを選択」を押してください。");
</script>
</body>
</html>
