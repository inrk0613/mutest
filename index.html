<!DOCTYPE html>
<html lang="ja">
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>
<script src="https://unpkg.com/@ffmpeg/util@0.11.0/dist/util.min.js"></script>
</head>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Silent Clipper | AI-Powered Video Silence Remover</title>
    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-color: #0A84FF;
            --text-color: #e0e0e0;
            --text-secondary-color: #888;
            --border-color: #333;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --border-radius: 12px;
            --transition-speed: 0.3s;
        }

        /* Reset and Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Main Application Layout */
        .app-container {
            width: 100%;
            max-width: 1200px;
            height: 95vh;
            max-height: 900px;
            background-color: var(--surface-color);
            border-radius: var(--border-radius);
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        header h1 {
            font-size: 1.25rem;
            font-weight: 600;
        }

        /* Main Content Area */
        main {
            display: flex;
            flex-grow: 1;
            height: 100%;
            min-height: 0; /* Important for flexbox shrinking */
        }
        
        .video-panel {
            flex-grow: 1;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
        }
        .controls-panel {
            width: 320px;
            flex-shrink: 0;
            border-left: 1px solid var(--border-color);
            padding: 1.5rem;
            overflow-y: auto;
        }

        /* File Drop Zone */
        .file-drop-zone {
            flex-grow: 1;
            border: 2px dashed var(--border-color);
            border-radius: var(--border-radius);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            cursor: pointer;
            transition: background-color var(--transition-speed), border-color var(--transition-speed);
        }
        .file-drop-zone.dragover {
            background-color: rgba(10, 132, 255, 0.1);
            border-color: var(--primary-color);
        }
        .file-drop-zone h2 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }
        .file-drop-zone p {
            color: var(--text-secondary-color);
        }
        #fileInput { display: none; }
        
        /* Video Player Area */
        .video-wrapper {
            position: relative;
            width: 100%;
            flex-grow: 1;
            background-color: #000;
            border-radius: var(--border-radius);
            overflow: hidden;
            display: none; /* Initially hidden */
        }
        #videoPlayer {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Histogram */
        #histogramCanvas {
            width: 100%;
            height: 80px;
            margin-top: 1rem;
            border-radius: 4px;
            background-color: #2a2a2a;
            cursor: crosshair;
        }
        
        /* Loading Spinner */
        .loader-overlay {
            position: absolute;
            inset: 0;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--border-color);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        #progressText {
            margin-top: 1rem;
            color: var(--text-color);
            font-size: 0.9rem;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }


        /* Controls Panel */
        .controls-panel h3 {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.75rem;
        }
        .control-group {
            margin-bottom: 1.5rem;
        }
        .control-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
            font-weight: 500;
        }
        .control-group .value {
            color: var(--text-secondary-color);
            font-weight: 400;
        }
        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: var(--border-color);
            outline: none;
            border-radius: 2px;
            transition: opacity var(--transition-speed);
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            cursor: pointer;
            border-radius: 50%;
        }
        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        /* Utility */
        .hidden { display: none !important; }

        /* Responsive */
        @media (max-width: 900px) {
            body { align-items: flex-start; }
            .app-container { 
                flex-direction: column; 
                height: 100vh;
                max-height: none;
                border-radius: 0;
            }
            main { flex-direction: column; }
            .controls-panel {
                width: 100%;
                border-left: none;
                border-top: 1px solid var(--border-color);
                max-height: 40vh;
            }
        }

    </style>
</head>
<body>

    <div class="app-container">
        <header>
            <h1>Silent Clipper</h1>
        </header>
        <main>
            <div class="video-panel">
                <div class="file-drop-zone" id="fileDropZone">
                    <input type="file" id="fileInput" accept="video/mp4,video/webm,video/quicktime">
                    <h2>ビデオファイルをドラッグ＆ドロップ</h2>
                    <p>またはクリックしてファイルを選択</p>
                </div>

                <div class="video-wrapper" id="videoWrapper">
                    <video id="videoPlayer" controls></video>
                    <div class="loader-overlay hidden" id="loaderOverlay">
                        <div class="spinner"></div>
                        <p id="progressText">準備中...</p>
                    </div>
                </div>

                <canvas id="histogramCanvas"></canvas>
            </div>
            <aside class="controls-panel" id="controlsPanel">
                <h3>設定</h3>
                <div class="export-section" style="margin-bottom: 1.5rem;">
    <button id="exportButton" style="...">書き出し</button>
    <div id="exportProgress" class="hidden" style="margin-top: 0.75rem;">
        <p id="exportProgressText" style="font-size: 0.9rem; margin-bottom: 0.5rem;"></p>
        <progress id="exportProgressBar" value="0" max="100" style="width: 100%;"></progress>
    </div>
</div>
                <div class="control-group">
                    <label for="thresholdSlider">無音しきい値 <span class="value" id="thresholdValue">-40 dB</span></label>
                    <input type="range" min="-60" max="-20" value="-40" class="slider" id="thresholdSlider">
                </div>
                <div class="control-group">
                    <label for="chunkSizeSlider">解析間隔 <span class="value" id="chunkSizeValue">50 ms</span></label>
                    <input type="range" min="10" max="200" value="50" step="10" class="slider" id="chunkSizeSlider">
                </div>
                <div class="control-group">
                    <label for="minSilenceSlider">最小無音長 <span class="value" id="minSilenceValue">500 ms</span></label>
                    <input type="range" min="100" max="2000" value="500" step="50" class="slider" id="minSilenceSlider">
                </div>
                <div class="control-group">
                    <label for="paddingSlider">マージン <span class="value" id="paddingValue">100 ms</span></label>
                    <input type="range" min="0" max="500" value="100" step="10" class="slider" id="paddingSlider">
                </div>
            </aside>
        </main>
    </div>

    <script type="module">
    // ===================================================================================
    // --- TYPE DEFINITIONS (JSDoc for TypeScript-like type safety) ---
    // ===================================================================================

    /**
     * @typedef {object} AudioChunk
     * @property {number} volume - The volume of the chunk in dBFS.
     */

    /**
     * @typedef {object} TimeRange
     * @property {number} start - Start time in seconds.
     * @property {number} end - End time in seconds.
     */

    /**
     * @typedef {object} AnalysisParams
     * @property {number} threshold
     * @property {number} chunkSize
     * @property {number} minSilenceDuration
     * @property {number} padding
     */
    
    // ===================================================================================
    // --- APPLICATION STATE ---
    // ===================================================================================
    
    const state = {
        /** @type {File | null} */
        videoFile: null,
        /** @type {string | null} */
        videoObjectURL: null,
        /** @type {Float32Array | null} */
        audioData: null,
        /** @type {number} */
        sampleRate: 0,
        /** @type {TimeRange[]} */
        soundZones: [],
        /** @type {boolean} */
        isProcessing: false,
        /** @type {number} */
        currentSoundZoneIndex: 0,
    };

    // ===================================================================================
    // --- DOM ELEMENTS ---
    // ===================================================================================
    
    const dom = {
        fileDropZone: document.getElementById('fileDropZone'),
        fileInput: document.getElementById('fileInput'),
        videoWrapper: document.getElementById('videoWrapper'),
        videoPlayer: document.getElementById('videoPlayer'),
        loaderOverlay: document.getElementById('loaderOverlay'),
        progressText: document.getElementById('progressText'),
        histogramCanvas: document.getElementById('histogramCanvas'),
        controlsPanel: document.getElementById('controlsPanel'),
        // Sliders
        thresholdSlider: document.getElementById('thresholdSlider'),
        chunkSizeSlider: document.getElementById('chunkSizeSlider'),
        minSilenceSlider: document.getElementById('minSilenceSlider'),
        paddingSlider: document.getElementById('paddingSlider'),
        // Slider value displays
        thresholdValue: document.getElementById('thresholdValue'),
        chunkSizeValue: document.getElementById('chunkSizeValue'),
        minSilenceValue: document.getElementById('minSilenceValue'),
        paddingValue: document.getElementById('paddingValue'),

        exportButton: document.getElementById('exportButton'),
    exportProgress: document.getElementById('exportProgress'),
    exportProgressText: document.getElementById('exportProgressText'),
    exportProgressBar: document.getElementById('exportProgressBar'),
    };
    
    const histogramCtx = dom.histogramCanvas.getContext('2d');
    
    // ===================================================================================
    // --- WEB WORKER INITIALIZATION ---
    // ===================================================================================

    // NOTE: This is the modern way to embed worker code in a single file without
    // creating a separate .js file. It's clean and efficient.
    const workerCode = `
        // --- WASM LOADER (inside worker) ---
        // In a real project, the .wasm file would be fetched. For single-file deployment,
        // it could be base64 encoded and embedded as a string constant.
        let wasm;
        async function loadWasm() {
            // This is a placeholder for loading your compiled Rust/C++ WASM module.
            // const wasmCode = await fetch('audio_processor.wasm');
            // const wasmModule = await WebAssembly.instantiateStreaming(wasmCode);
            // wasm = wasmModule.instance.exports;
            
            // For now, we'll simulate the WASM with a JS function.
            wasm = {
                // This function simulates the high-performance RMS calculation from WASM.
                calculate_rms_dbfs_for_chunks: (audioData, sampleRate, chunkSizeMs) => {
                    const chunkSamples = Math.floor(sampleRate * (chunkSizeMs / 1000));
                    const numChunks = Math.floor(audioData.length / chunkSamples);
                    const volumes = new Float32Array(numChunks);
                    for (let i = 0; i < numChunks; i++) {
                        let sumOfSquares = 0;
                        const start = i * chunkSamples;
                        const end = start + chunkSamples;
                        for (let j = start; j < end; j++) {
                            sumOfSquares += audioData[j] * audioData[j];
                        }
                        const rms = Math.sqrt(sumOfSquares / chunkSamples);
                        volumes[i] = 20 * Math.log10(rms);
                    }
                    return volumes;
                }
            };
            console.log("WASM module (simulated) loaded in worker.");
        }
        
        self.onmessage = async (e) => {
            const { type, payload } = e.data;
            if (type === 'ANALYZE') {
                if (!wasm) await loadWasm();
                
                self.postMessage({ type: 'PROGRESS', payload: { text: '音声データをデコード中...' } });

                // 1. Decode Audio Data
                // OfflineAudioContext is the fastest way to decode audio in the background.
                const audioCtx = new OfflineAudioContext(1, payload.audioData.length, payload.sampleRate);
                const source = audioCtx.createBufferSource();
                source.buffer = audioCtx.createBuffer(1, payload.audioData.length, payload.sampleRate);
                source.buffer.copyToChannel(payload.audioData, 0);
                
                const decodedBuffer = await audioCtx.startRendering();
                const decodedAudioData = decodedBuffer.getChannelData(0);

                self.postMessage({ type: 'PROGRESS', payload: { text: '音量を解析中 (WASM)...' } });
                
                // 2. Perform high-speed analysis via WASM
                const volumes = wasm.calculate_rms_dbfs_for_chunks(
                    decodedAudioData,
                    payload.sampleRate,
                    payload.params.chunkSize
                );

                // Send histogram data back to the main thread
                self.postMessage({ type: 'HISTOGRAM_DATA', payload: volumes });

                self.postMessage({ type: 'PROGRESS', payload: { text: '無音区間を検出中...' } });

                // 3. Identify silent chunks
                const isSilent = new Uint8Array(volumes.length);
                for (let i = 0; i < volumes.length; i++) {
                    if (volumes[i] < payload.params.threshold) {
                        isSilent[i] = 1;
                    }
                }
                
                // 4. Merge silent chunks and create sound zones
                const minSilenceChunks = Math.ceil(payload.params.minSilenceDuration / payload.params.chunkSize);
                const paddingSeconds = payload.params.padding / 1000;
                const chunkSizeSeconds = payload.params.chunkSize / 1000;

                const soundZones = [];
                let lastSoundEnd = 0;
                let silentChunkCount = 0;

                for (let i = 0; i < isSilent.length; i++) {
                    if (isSilent[i]) {
                        silentChunkCount++;
                    } else {
                        if (silentChunkCount >= minSilenceChunks) {
                            const silenceStart = (i - silentChunkCount) * chunkSizeSeconds;
                            if (lastSoundEnd < silenceStart) {
                                soundZones.push({
                                    start: Math.max(0, lastSoundEnd - paddingSeconds),
                                    end: Math.min(silenceStart + paddingSeconds, (i * chunkSizeSeconds))
                                });
                            }
                        }
                        lastSoundEnd = (i + 1) * chunkSizeSeconds;
                        silentChunkCount = 0;
                    }
                }
                
                // Add the final sound zone if any
                if (lastSoundEnd < (volumes.length * chunkSizeSeconds)) {
                     soundZones.push({
                         start: Math.max(0, lastSoundEnd - paddingSeconds),
                         end: (volumes.length * chunkSizeSeconds)
                     });
                }
                
                // Merge overlapping zones
                if (soundZones.length > 0) {
                    const mergedZones = [soundZones[0]];
                    for(let i = 1; i < soundZones.length; i++) {
                        const lastZone = mergedZones[mergedZones.length - 1];
                        const currentZone = soundZones[i];
                        if (currentZone.start <= lastZone.end) {
                            lastZone.end = Math.max(lastZone.end, currentZone.end);
                        } else {
                            mergedZones.push(currentZone);
                        }
                    }
                    self.postMessage({ type: 'ANALYSIS_COMPLETE', payload: { soundZones: mergedZones } });
                } else {
                     self.postMessage({ type: 'ANALYSIS_COMPLETE', payload: { soundZones: [] } });
                }
            }
        };
    `;
    const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
    const worker = new Worker(URL.createObjectURL(workerBlob));

    // ===================================================================================
    // --- MAIN THREAD LOGIC ---
    // ===================================================================================

    /**
     * Handles file selection (drag-drop or click)
     * @param {File} file The selected video file.
     */
    async function handleFileSelect(file) {
        if (!file || !file.type.startsWith('video/')) {
            alert('有効なビデオファイルを選択してください。');
            return;
        }
        
        state.videoFile = file;
        setProcessingState(true, 'ファイルを読み込み中...');

        if (state.videoObjectURL) {
            URL.revokeObjectURL(state.videoObjectURL);
        }
        state.videoObjectURL = URL.createObjectURL(file);
        dom.videoPlayer.src = state.videoObjectURL;

        dom.fileDropZone.classList.add('hidden');
        dom.videoWrapper.style.display = 'block';
        
        try {
            const fileBuffer = await file.arrayBuffer();
            // Using a temporary AudioContext to decode audio data fast on the main thread
            // just to get the raw data. The heavy lifting happens in the worker.
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const audioBuffer = await audioContext.decodeAudioData(fileBuffer);
            
            state.audioData = audioBuffer.getChannelData(0);
            state.sampleRate = audioBuffer.sampleRate;
            
            triggerAnalysis();
        } catch (err) {
            console.error('Error processing audio:', err);
            alert('音声トラックの処理に失敗しました。ファイルが破損しているか、サポートされていない形式の可能性があります。');
            setProcessingState(false);
        }
    }
    
    /**
     * Triggers the analysis in the Web Worker
     */
    function triggerAnalysis() {
        if (!state.audioData || state.isProcessing) return;
        
        setProcessingState(true, '解析の準備中...');
        
        const params = {
            threshold: parseFloat(dom.thresholdSlider.value),
            chunkSize: parseInt(dom.chunkSizeSlider.value, 10),
            minSilenceDuration: parseInt(dom.minSilenceSlider.value, 10),
            padding: parseInt(dom.paddingSlider.value, 10),
        };

        // Transfer AudioData to worker to avoid copying large amounts of data
        worker.postMessage({
            type: 'ANALYZE',
            payload: {
                audioData: state.audioData,
                sampleRate: state.sampleRate,
                params: params,
            }
        }, [state.audioData.buffer]);
    }
    
    /**
     * Updates the UI to reflect processing state
     * @param {boolean} isProcessing
     * @param {string} [text='']
     */
    function setProcessingState(isProcessing, text = '') {
        state.isProcessing = isProcessing;
        dom.loaderOverlay.classList.toggle('hidden', !isProcessing);
        dom.progressText.textContent = text;
        
        // Disable sliders during processing
        [dom.thresholdSlider, dom.chunkSizeSlider, dom.minSilenceSlider, dom.paddingSlider]
            .forEach(slider => slider.disabled = isProcessing);
    }
    
    /**
     * Draws the volume histogram on the canvas
     * @param {Float32Array} volumes 
     */
    function drawHistogram(volumes) {
        const { width, height } = dom.histogramCanvas;
        histogramCtx.clearRect(0, 0, width, height);

        const barWidth = width / volumes.length;
        const threshold = parseFloat(dom.thresholdSlider.value);
        
        // Define a gradient for the bars
        const gradient = histogramCtx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, 'rgba(10, 132, 255, 0.8)'); // Primary color
        gradient.addColorStop(1, 'rgba(10, 132, 255, 0.3)');
        
        const silentColor = 'rgba(255, 80, 80, 0.5)'; // A color for silent parts
        
        for (let i = 0; i < volumes.length; i++) {
            const db = volumes[i];
            // Normalize dB to a 0-1 range. Assume a range of -80dB to 0dB.
            const normalizedHeight = (db + 80) / 80;
            const barHeight = Math.max(1, normalizedHeight * height);

            histogramCtx.fillStyle = db < threshold ? silentColor : gradient;
            histogramCtx.fillRect(i * barWidth, height - barHeight, barWidth, barHeight);
        }
    }

    /**
     * Handles the preview playback logic
     */
    function handleTimeUpdate() {
        if (state.soundZones.length === 0 || dom.videoPlayer.paused) return;

        const currentTime = dom.videoPlayer.currentTime;
        const currentZone = state.soundZones[state.currentSoundZoneIndex];

        if (currentTime >= currentZone.end) {
            const nextZoneIndex = state.currentSoundZoneIndex + 1;
            if (nextZoneIndex < state.soundZones.length) {
                state.currentSoundZoneIndex = nextZoneIndex;
                dom.videoPlayer.currentTime = state.soundZones[nextZoneIndex].start;
                dom.videoPlayer.play();
            } else {
                dom.videoPlayer.pause();
                dom.videoPlayer.currentTime = state.soundZones[0].start; // Loop back
                state.currentSoundZoneIndex = 0;
            }
        }
    }
    
    // ===================================================================================
    // --- EVENT LISTENERS ---
    // ===================================================================================

    // File Drop Zone events
    dom.fileDropZone.addEventListener('click', () => dom.fileInput.click());
    dom.fileInput.addEventListener('change', (e) => handleFileSelect(e.target.files[0]));
    dom.fileDropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dom.fileDropZone.classList.add('dragover');
    });
    dom.fileDropZone.addEventListener('dragleave', () => dom.fileDropZone.classList.remove('dragover'));
    dom.fileDropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dom.fileDropZone.classList.remove('dragover');
        handleFileSelect(e.dataTransfer.files[0]);
    });
    
    // Worker message handler
    worker.onmessage = (e) => {
        const { type, payload } = e.data;
        if (type === 'PROGRESS') {
            setProcessingState(true, payload.text);
        } else if (type === 'HISTOGRAM_DATA') {
            drawHistogram(payload);
        } else if (type === 'ANALYSIS_COMPLETE') {
            // Restore audio data buffer after transfer
            state.audioData = new Float32Array(e.data.payload.audioDataBuffer);
            
            state.soundZones = payload.soundZones;
            setProcessingState(false);
            
            if (state.soundZones.length > 0) {
                dom.videoPlayer.currentTime = state.soundZones[0].start;
                state.currentSoundZoneIndex = 0;
                console.log('Analysis complete. Sound zones:', state.soundZones);
            } else {
                alert('解析の結果、音声区間が見つかりませんでした。');
            }
        }
    };
    
    // Slider events
    const sliders = [
        { el: dom.thresholdSlider, elValue: dom.thresholdValue, unit: ' dB' },
        { el: dom.chunkSizeSlider, elValue: dom.chunkSizeValue, unit: ' ms' },
        { el: dom.minSilenceSlider, elValue: dom.minSilenceValue, unit: ' ms' },
        { el: dom.paddingSlider, elValue: dom.paddingValue, unit: ' ms' },
    ];
    sliders.forEach(({el, elValue, unit}) => {
        el.addEventListener('input', () => {
            elValue.textContent = `${el.value}${unit}`;
        });
        // Re-analyze when user stops dragging the slider
        el.addEventListener('change', triggerAnalysis);
    });
    
    // Video player events
    dom.videoPlayer.addEventListener('timeupdate', handleTimeUpdate);
    dom.videoPlayer.addEventListener('seeking', () => {
        // Find the correct sound zone to be in after user seeks
        const currentTime = dom.videoPlayer.currentTime;
        const zoneIndex = state.soundZones.findIndex(zone => currentTime >= zone.start && currentTime < zone.end);
        state.currentSoundZoneIndex = (zoneIndex !== -1) ? zoneIndex : 0;
    });

    </script>
</body>
</html>
