<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Silent Cutter - The Art of Silence</title>
    <meta name="description" content="Blazing-fast, beautiful, and private. Automatically cut silent parts from your videos, right in your browser.">
    
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- Reset & Base Styles --- */
        :root {
            --color-bg: #000000;
            --color-surface: #121212;
            --color-surface-2: #1e1e1e;
            --color-primary: #007aff;
            --color-primary-hover: #0088ff;
            --color-text: #f5f5f7;
            --color-text-secondary: #8a8a8e;
            --color-border: #3a3a3c;
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            --transition-fast: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        *, *::before, *::after { box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body {
            font-family: var(--font-family);
            background-color: var(--color-bg);
            color: var(--color-text);
            margin: 0;
            padding: 1rem;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        #app {
            width: 100%;
            max-width: 1400px;
            margin: auto;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.8s 0.2s ease-out forwards;
        }
        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* --- Layout --- */
        .main-layout {
            display: grid;
            grid-template-columns: 300px 1fr;
            grid-template-rows: auto 1fr;
            gap: 2rem;
            width: 100%;
            display: none; /* Initially hidden */
        }
        .main-layout.visible {
            display: grid;
        }
        .controls-panel { 
            grid-row: 1 / 3;
            background-color: var(--color-surface);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--color-border);
        }
        .video-wrapper {
            grid-column: 2 / 3;
            background-color: #000;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--color-border);
        }
        .timeline-wrapper {
            grid-column: 2 / 3;
            height: 100px;
        }
        
        /* --- Dropzone --- */
        #dropzone {
            border: 2px dashed var(--color-border);
            border-radius: 16px;
            padding: 4rem 2rem;
            text-align: center;
            cursor: pointer;
            transition: var(--transition-fast);
            background-color: var(--color-surface);
        }
        #dropzone.dragging {
            border-color: var(--color-primary);
            background-color: var(--color-surface-2);
        }
        #dropzone p {
            margin: 0;
            font-size: 1.2rem;
            color: var(--color-text-secondary);
        }
        
        /* --- Controls --- */
        .control-group { margin-bottom: 2rem; }
        .control-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.75rem;
            font-weight: 500;
        }
        .control-group .value { color: var(--color-text-secondary); }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: var(--color-surface-2);
            border-radius: 2px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--color-primary);
            border-radius: 50%;
            cursor: pointer;
            transition: var(--transition-fast);
        }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.1); }
        
        /* --- Video & Timeline --- */
        #preview-video { width: 100%; display: block; }
        #custom-timeline {
            width: 100%;
            height: 100%;
            background-color: var(--color-surface);
            border-radius: 12px;
            cursor: pointer;
            border: 1px solid var(--color-border);
        }
        
        /* --- Status & Progress --- */
        #status-bar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(30, 30, 30, 0.8);
            backdrop-filter: blur(10px);
            padding: 0.75rem 1.5rem;
            border-radius: 20px;
            border: 1px solid var(--color-border);
            text-align: center;
            opacity: 0;
            transition: var(--transition-fast);
        }
        #status-bar.visible { opacity: 1; }
        #status-message { margin: 0; font-weight: 500; }
        #progress-bar {
            width: 100%;
            height: 4px;
            margin-top: 0.5rem;
            display: block;
            appearance: none; -webkit-appearance: none;
        }
        #progress-bar::-webkit-progress-bar { background-color: var(--color-border); border-radius: 2px; }
        #progress-bar::-webkit-progress-value { background-color: var(--color-primary); border-radius: 2px; transition: width 0.3s ease; }
        
        /* --- Responsive --- */
        @media (max-width: 1024px) {
            body { padding: 0.5rem; }
            .main-layout {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto auto;
            }
            .controls-panel { grid-row: 3 / 4; }
            .video-wrapper { grid-row: 1 / 2; grid-column: 1 / 2; }
            .timeline-wrapper { grid-row: 2 / 3; grid-column: 1 / 2; }
        }
    </style>
</head>
<body>

    <main id="app">
        <!-- 1. Initial Dropzone View -->
        <section id="dropzone">
            <input type="file" id="file-input" accept="video/mp4,video/webm,video/quicktime" hidden>
            <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="color: var(--color-text-secondary); margin-bottom: 1rem;"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
            <p>Drag & Drop a video file, or click to select</p>
        </section>

        <!-- 2. Main Application Layout (hidden by default) -->
        <div id="main-layout" class="main-layout">
            <div class="video-wrapper">
                <video id="preview-video"></video>
            </div>
            <div class="timeline-wrapper">
                <svg id="custom-timeline"></svg>
            </div>
            <aside class="controls-panel">
                <div class="control-group">
                    <label><span>Threshold</span><span class="value" id="threshold-value">-40 dB</span></label>
                    <input type="range" id="threshold-slider" min="-60" max="-20" value="-40" step="1">
                </div>
                <div class="control-group">
                    <label><span>Min Silence Duration</span><span class="value" id="min-silence-value">500 ms</span></label>
                    <input type="range" id="min-silence-slider" min="100" max="2000" value="500" step="50">
                </div>
                <div class="control-group">
                    <label><span>Padding</span><span class="value" id="padding-value">150 ms</span></label>
                    <input type="range" id="padding-slider" min="0" max="500" value="150" step="10">
                </div>
                <div class="control-group" style="opacity: 0.5; cursor: not-allowed;">
                    <label><span>Chunk Size</span><span class="value" id="chunk-size-value">10 ms</span></label>
                    <input type="range" id="chunk-size-slider" min="10" max="50" value="10" step="1" disabled>
                    <small style="color: var(--color-text-secondary); font-size: 0.75rem;">Lower is more accurate but slower. (Fixed at 10ms for performance)</small>
                </div>
            </aside>
        </div>

        <!-- 3. Status Bar -->
        <div id="status-bar">
            <p id="status-message"></p>
            <progress id="progress-bar" value="0" max="100" style="display: none;"></progress>
        </div>
    </main>
    
    <!-- 
    ================================================================
    Web Worker (Analyzer)
    ================================================================
    -->
    <script id="analyzer-worker" type="javascript/worker">
        let wasm;
        
        // This is a placeholder for the Base64 encoded WASM module.
        // In a real build process, this would be auto-populated.
        // This small, valid WASM module exports 'add(a,b)' and memory.
        const wasmBase64 = "AGFzbQEAAAABBgFgAXwBfAABAwIBAAUDAgABBggBBwJtZW1vcnkCAAEAA2FkZAAACgYBAAAGACAAQQAhAAYALABAAQAL";

        async function initWasm() {
            if (wasm) return;
            const wasmBinary = Uint8Array.from(atob(wasmBase64), c => c.charCodeAt(0));
            const wasmModule = await WebAssembly.compile(wasmBinary);
            const { instance } = await WebAssembly.instantiate(wasmModule, {
                env: { memory: new WebAssembly.Memory({ initial: 10 }) }
            });
            wasm = instance.exports;
            // In a real module, you'd have functions like:
            // wasm.init_panic_hook();
            // wasm.analyze(...);
        }

        async function decodeAudioData(file) {
            const arrayBuffer = await file.arrayBuffer();
            const ctx = new OfflineAudioContext(1, 1, 48000); // Use a fixed, high sample rate
            return ctx.decodeAudioData(arrayBuffer);
        }

        /**
         * A mock analysis function that simulates the real WASM call.
         * This is where the actual high-performance Rust code would run.
         */
        function mockAnalyze(audioData, sampleRate, settings) {
             const duration = audioData.length / sampleRate;
             const audibleIntervals = [];
             let lastEnd = 0;

             // Simulate finding silent parts
             for (let i = 0; i < 10; i++) {
                 const start = lastEnd + Math.random() * (duration / 20);
                 const end = start + Math.random() * (duration / 10);
                 if (end > duration) break;
                 
                 // Apply padding (virtually)
                 const paddedStart = Math.max(0, start - (settings.padding / 1000));
                 const paddedEnd = Math.min(duration, end + (settings.padding / 1000));

                 if (paddedStart > lastEnd) {
                    audibleIntervals.push([lastEnd, paddedStart]);
                 }
                 lastEnd = paddedEnd;
             }
             if (lastEnd < duration) {
                 audibleIntervals.push([lastEnd, duration]);
             }
             return { audibleIntervals };
        }

        self.onmessage = async (event) => {
            try {
                const { file, settings } = event.data;
                await initWasm();

                postMessage({ type: 'progress', message: 'Decoding audio...', progress: 10 });
                const audioBuffer = await decodeAudioData(file);
                const audioData = audioBuffer.getChannelData(0);

                postMessage({ type: 'progress', message: 'Analyzing for silence...', progress: 40 });
                
                // TODO: Replace mockAnalyze with real WASM call
                // const wasmResult = wasm.analyze(audioData, audioBuffer.sampleRate, settings...);
                const { audibleIntervals } = mockAnalyze(audioData, audioBuffer.sampleRate, settings);

                // Simulate processing time
                await new Promise(res => setTimeout(res, 500 + Math.random() * 1000));

                postMessage({ type: 'progress', message: 'Analysis complete', progress: 100 });
                postMessage({ type: 'result', audibleIntervals });

            } catch (error) {
                console.error('Worker error:', error);
                postMessage({ type: 'error', message: `Analysis failed: ${error.message}` });
            }
        };
    </script>
    
    <!-- 
    ================================================================
    Main Application Logic (TypeScript-in-JS style)
    ================================================================
    -->
    <script type="module">
        // --- DOM Elements ---
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('file-input');
        const mainLayout = document.getElementById('main-layout');
        const videoEl = document.getElementById('preview-video');
        const timelineEl = document.getElementById('custom-timeline');
        const statusBar = document.getElementById('status-bar');
        const statusMessage = document.getElementById('status-message');
        const progressBar = document.getElementById('progress-bar');
        
        const sliders = {
            threshold: document.getElementById('threshold-slider'),
            minSilence: document.getElementById('min-silence-slider'),
            padding: document.getElementById('padding-slider'),
        };
        const values = {
            threshold: document.getElementById('threshold-value'),
            minSilence: document.getElementById('min-silence-value'),
            padding: document.getElementById('padding-value'),
        };

        // --- State ---
        let state = {
            file: null,
            audibleIntervals: [],
            currentIntervalIndex: 0,
            isPlaying: false,
            isSeeking: false,
            totalAudibleDuration: 0,
        };
        let analyzerWorker;
        let debounceTimer;

        // --- Initialization ---
        function init() {
            setupWorker();
            setupEventListeners();
        }

        function setupWorker() {
            const workerScript = document.getElementById('analyzer-worker').textContent;
            const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
            analyzerWorker = new Worker(URL.createObjectURL(workerBlob));
            analyzerWorker.onmessage = handleWorkerMessage;
        }
        
        function setupEventListeners() {
            dropzone.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => handleFileSelect(e.target.files));
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropzone.addEventListener(eventName, preventDefaults, false);
            });
            ['dragenter', 'dragover'].forEach(eventName => {
                dropzone.addEventListener(eventName, () => dropzone.classList.add('dragging'), false);
            });
            ['dragleave', 'drop'].forEach(eventName => {
                dropzone.addEventListener(eventName, () => dropzone.classList.remove('dragging'), false);
            });
            dropzone.addEventListener('drop', handleFileDrop, false);

            Object.values(sliders).forEach(slider => {
                slider.addEventListener('input', handleSettingsChange);
            });
            
            videoEl.addEventListener('play', () => { state.isPlaying = true; });
            videoEl.addEventListener('pause', () => { state.isPlaying = false; });
            videoEl.addEventListener('ended', () => { state.isPlaying = false; });
            
            timelineEl.addEventListener('click', handleTimelineSeek);
        }
        
        // --- File Handling ---
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        function handleFileDrop(e) {
            handleFileSelect(e.dataTransfer.files);
        }
        
        function handleFileSelect(files) {
            if (files.length === 0) return;
            const file = files[0];
            if (!file.type.startsWith('video/')) {
                showStatus('Error: Please select a valid video file.', 'error', 5000);
                return;
            }
            state.file = file;
            startAnalysis();
        }

        // --- Analysis ---
        function getSettings() {
            return {
                threshold: parseInt(sliders.threshold.value, 10),
                minSilenceDuration: parseInt(sliders.minSilence.value, 10),
                padding: parseInt(sliders.padding.value, 10),
                chunkSize: 10, // Fixed
            };
        }
        
        function startAnalysis() {
            if (!state.file) return;
            
            showStatus('Starting analysis...', 'info');
            progressBar.style.display = 'block';
            progressBar.value = 0;
            
            // Set up video source for metadata loading
            const videoURL = URL.createObjectURL(state.file);
            videoEl.src = videoURL;
            videoEl.load();

            analyzerWorker.postMessage({ file: state.file, settings: getSettings() });
        }
        
        function handleWorkerMessage(e) {
            const { type, message, progress, audibleIntervals, error } = e.data;
            switch (type) {
                case 'progress':
                    showStatus(message, 'info');
                    progressBar.value = progress;
                    break;
                case 'result':
                    hideStatus();
                    progressBar.style.display = 'none';
                    state.audibleIntervals = audibleIntervals;
                    state.totalAudibleDuration = audibleIntervals.reduce((sum, [start, end]) => sum + (end - start), 0);
                    showMainLayout();
                    drawTimeline();
                    setupPreviewPlayback();
                    break;
                case 'error':
                    showStatus(`Error: ${message}`, 'error', 5000);
                    progressBar.style.display = 'none';
                    break;
            }
        }

        function handleSettingsChange(e) {
            const id = e.target.id;
            if (id === 'threshold-slider') values.threshold.textContent = `${e.target.value} dB`;
            if (id === 'min-silence-slider') values.minSilence.textContent = `${e.target.value} ms`;
            if (id === 'padding-slider') values.padding.textContent = `${e.target.value} ms`;

            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                showStatus('Re-analyzing with new settings...', 'info');
                startAnalysis();
            }, 500);
        }

        // --- UI Management ---
        function showStatus(message, type = 'info', duration = 0) {
            statusMessage.textContent = message;
            statusBar.className = `visible ${type}`;
            if (duration > 0) {
                setTimeout(hideStatus, duration);
            }
        }

        function hideStatus() {
            statusBar.classList.remove('visible');
        }

        function showMainLayout() {
            dropzone.style.display = 'none';
            mainLayout.classList.add('visible');
        }

        // --- Timeline & Playback ---
        function drawTimeline() {
            const duration = videoEl.duration;
            if (!duration || !isFinite(duration)) return;
            
            const width = timelineEl.clientWidth;
            const height = timelineEl.clientHeight;
            let html = `<rect x="0" y="0" width="${width}" height="${height}" fill="var(--color-surface-2)" />`;

            state.audibleIntervals.forEach(([start, end]) => {
                const x = (start / duration) * width;
                const w = ((end - start) / duration) * width;
                html += `<rect x="${x}" y="0" width="${w}" height="${height}" fill="var(--color-primary)" />`;
            });

            // Playhead
            html += `<line id="playhead" x1="0" y1="0" x2="0" y2="${height}" stroke="${var(--color-text)}" stroke-width="2" />`;

            timelineEl.innerHTML = html;
        }
        
        function updatePlayhead() {
            if (!videoEl.duration) return;
            const playhead = document.getElementById('playhead');
            if (!playhead) return;
            
            const audiblePlayedTime = state.audibleIntervals
                .slice(0, state.currentIntervalIndex)
                .reduce((sum, [start, end]) => sum + (end - start), 0)
                + (videoEl.currentTime - state.audibleIntervals[state.currentIntervalIndex][0]);
            
            const progress = audiblePlayedTime / state.totalAudibleDuration;
            const x = progress * timelineEl.clientWidth;

            playhead.setAttribute('x1', x);
            playhead.setAttribute('x2', x);
        }
        
        function setupPreviewPlayback() {
            state.currentIntervalIndex = 0;
            videoEl.currentTime = state.audibleIntervals[0][0];
            
            videoEl.ontimeupdate = () => {
                if (state.isSeeking) return;
                
                const [start, end] = state.audibleIntervals[state.currentIntervalIndex];
                
                if (videoEl.currentTime >= end) {
                    state.currentIntervalIndex++;
                    if (state.currentIntervalIndex >= state.audibleIntervals.length) {
                        videoEl.pause();
                        state.currentIntervalIndex = 0;
                        videoEl.currentTime = state.audibleIntervals[0][0];
                    } else {
                        videoEl.currentTime = state.audibleIntervals[state.currentIntervalIndex][0];
                    }
                }
                updatePlayhead();
            };
        }

        function handleTimelineSeek(e) {
            const bounds = timelineEl.getBoundingClientRect();
            const progress = (e.clientX - bounds.left) / bounds.width;
            
            const targetAudibleTime = progress * state.totalAudibleDuration;
            let accumulatedTime = 0;

            for(let i=0; i<state.audibleIntervals.length; i++) {
                const [start, end] = state.audibleIntervals[i];
                const duration = end - start;
                if (accumulatedTime + duration >= targetAudibleTime) {
                    const timeIntoInterval = targetAudibleTime - accumulatedTime;
                    state.currentIntervalIndex = i;
                    videoEl.currentTime = start + timeIntoInterval;
                    break;
                }
                accumulatedTime += duration;
            }
        }

        // --- Start the app ---
        init();
    </script>

</body>
</html>
